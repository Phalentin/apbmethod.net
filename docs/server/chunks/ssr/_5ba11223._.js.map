{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/_meta.js"],"sourcesContent":["export default {\n  index: 'Welcome',\n  tutorial: {\n    title: 'Tutorial'\n  },\n  advanced: {\n    title: 'Advanced'\n  },\n  variations: {\n    title: 'Variations'\n  },\n  /*'3x3oh': {\n    title: '3x3 One-Handed',\n    type: 'page'\n  },*/\n  'big-cubes': {\n    title: '4x4+'\n  },\n  'other-resources': 'Other Resources'\n}"],"names":[],"mappings":";;;;uCAAe;IACb,OAAO;IACP,UAAU;QACR,OAAO;IACT;IACA,UAAU;QACR,OAAO;IACT;IACA,YAAY;QACV,OAAO;IACT;IACA;;;IAGE,GACF,aAAa;QACX,OAAO;IACT;IACA,mBAAmB;AACrB","debugId":null}},
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/advanced/_meta.js"],"sourcesContent":["export default {\n  pair: 'Advanced BR Pair',\n  zbll: 'Advanced Last Layer (ZBLL)'\n}"],"names":[],"mappings":";;;;uCAAe;IACb,MAAM;IACN,MAAM;AACR","debugId":null}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/mdx-components.js"],"sourcesContent":["import { useMDXComponents as getThemeComponents } from 'nextra-theme-docs' // nextra-theme-blog or your custom theme\n \n// Get the default MDX components\nconst themeComponents = getThemeComponents()\n \n// Merge components\nexport function useMDXComponents(components) {\n  return {\n    ...themeComponents,\n    ...components\n  }\n}"],"names":[],"mappings":";;;;AAAA,6SAA2E,yCAAyC;;AAEpH,iCAAiC;AACjC,MAAM,kBAAkB,IAAA,iMAAkB;AAGnC,SAAS,iBAAiB,UAAU;IACzC,OAAO;QACL,GAAG,eAAe;QAClB,GAAG,UAAU;IACf;AACF","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/advanced/pair.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"Solving the BR Pair Algorithmically\",\n  \"filePath\": \"content/advanced/pair.mdx\",\n  \"timestamp\": 1758384364947\n};\nexport const sourceCode = \"# Solving the BR Pair Algorithmically\\nAfter you have got comfortable with all the algorithms of APB, you should start learning the optimal solutions for solving the back-right pair. This is especially important for the cases where the edge is misoriented.\\n\\nThe algorithms can be found [here](https://docs.google.com/spreadsheets/d/1U1nwq_-HLeDgajuAOVRaH2Jo7X9zSTEBrnIRSv3hzeg/edit?gid=983211243#gid=983211243).\";\nfunction useTOC(props) {\n  return [];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><_components.h1>{\"Solving the BR Pair Algorithmically\"}</_components.h1>{\"\\n\"}<_components.p>{\"After you have got comfortable with all the algorithms of APB, you should start learning the optimal solutions for solving the back-right pair. This is especially important for the cases where the edge is misoriented.\"}</_components.p>{\"\\n\"}<_components.p>{\"The algorithms can be found \"}<_components.a href=\"https://docs.google.com/spreadsheets/d/1U1nwq_-HLeDgajuAOVRaH2Jo7X9zSTEBrnIRSv3hzeg/edit?gid=983211243#gid=983211243\">{\"here\"}</_components.a>{\".\"}</_components.p></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"AAAA,uBAAuB,GACvB,wBAAwB;;;;;;;;;;;AACxB;;;AACO,MAAM,WAAW;IACtB,SAAS;IACT,YAAY;IACZ,aAAa;AACf;AACO,MAAM,aAAa;AAC1B,SAAS,OAAO,KAAK;IACnB,OAAO,EAAE;AACX;AACO,MAAM,MAAM,OAAO,CAAC;AAC3B,SAAS,kBAAkB,KAAK;IAC9B,MAAM,cAAc;QAClB,GAAG;QACH,IAAI;QACJ,GAAG;QACH,GAAG,IAAA,qIAAkB,GAAE;QACvB,GAAG,MAAM,UAAU;IACrB;IACA,qBAAO;;0BAAE,8OAAC,YAAY,EAAE;0BAAE;;;;;;YAAwD;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAA6O;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAA+B,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAwH;;;;;;oBAAwB;;;;;;;;;AAC9iB;uCACe","debugId":null}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/advanced/zbll.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"Advanced Last Layer (ZBLL)\",\n  \"filePath\": \"content/advanced/zbll.mdx\",\n  \"timestamp\": 1758384363254\n};\nimport Image from 'next/image';\nexport const sourceCode = \"import Image from 'next/image'\\n\\n<Image src=\\\"/images/tutorial/pair.svg\\\" width={200} height={200} alt=\\\"Image of a cube with the BR pair solved\\\"/>\\n# 2. Solving the BR Pair\\n**Solving the dBR pair** is the second step of APB. This is probably the most trivial step, as it can be completed **intuitively** and CFOP-solvers will already be familiar with it.\\n\\n## Oriented BR Edge\\nIf the BR edge is oriented (e.g. its back color is on top, bottom or at the front right), the standard CFOP solution will be the fastest most of the time. It is, however, often possible not to undo R-moves (see example).\\n<twisty-player\\n    experimentalStickeringMaskOrbits=\\\"EDGES:-I--IIII--I-,CORNERS:-I--IIII\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2\\\"\\n    alg=\\\"R U' R\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"45\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/>\\n\\n## Misoriented BR Edge\\nWhen the BR edge is misoriented (e.g. its right color is on top, bottom, at the front right or back right), there are often **fast solutions using S-moves** (see example). If there is no fancy S-move solution, you can connect the two pieces and then insert them by doing `f R' f'`.\\n<twisty-player\\n    experimentalStickeringMaskOrbits=\\\"EDGES:-I--IIII--I-,CORNERS:-I--IIII\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2\\\"\\n    alg=\\\"S R' S'\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"45\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/>\\n\\n## Algorithm Sheet\\n**For some cases**, especially those with a misoriented edge, **learning the most efficient solution is really helpful**. Those solutions can be found in [Liam Highducheck's sheet](https://docs.google.com/spreadsheets/d/1U1nwq_-HLeDgajuAOVRaH2Jo7X9zSTEBrnIRSv3hzeg/edit?gid=983211243#gid=983211243).\";\nfunction useTOC(props) {\n  return [{\n    value: \"How to Approach Learning ZBLL\",\n    id: \"how-to-approach-learning-zbll\",\n    depth: 2\n  }, {\n    value: \"Algorithm Sources\",\n    id: \"algorithm-sources\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    h2: \"h2\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/advanced/zbll.svg\" width={200} height={200} alt=\"Image of a cube with an EOPair case\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;r=y35x-25&amp;bg=t&amp;fc=dydyyydyddddrrrrrrdddbbbbbb\" />{\"\\n\"}<_components.h1>{\"Advanced Last Layer (ZBLL)\"}</_components.h1>{\"\\n\"}<_components.p>{\"If you have gotten comfortable with APB and have already learned full LXS, you should really start thinking about learning ZBLL. \"}<_components.strong>{\"APB was developed with ZBLL in mind\"}</_components.strong>{\" and it is really only competitive at a high level if you know ZBLL.\"}</_components.p>{\"\\n\"}<_components.p>{\"ZBLL solves the whole \"}<_components.strong>{\"last layer in one step\"}</_components.strong>{\". Because in APB, the edges are all oriented, the number of algorithms for this step is “only” 493. 21 of those are the PLL cases which you probably already know. ZBLL is divided into eight subsets, corresponding to the cross solved OLL cases and PLL: U, T, L, Pi, H, Sune, Antisune and PLL. These subsets all consist of 72 algorithms, except for H (48) and PLL (21). The recommended order for learning ZBLL is the following:\"}</_components.p>{\"\\n\"}<_components.ol start=\"0\">{\"\\n\"}<_components.li>{\"PLL\"}</_components.li>{\"\\n\"}<_components.li>{\"U, T and L\"}</_components.li>{\"\\n\"}<_components.li>{\"Pi and H\"}</_components.li>{\"\\n\"}<_components.li>{\"Sune and Antisune\"}</_components.li>{\"\\n\"}</_components.ol>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<_components.p>{\"It is recommended, to set yourself a goal of \"}<_components.strong>{\"N cases per M days\"}</_components.strong>{\". A reasonable example would be twelve cases (a sub-subset) per week. However, you should not set a goal like one case per day. It is better to learn multiple cases on the same day and then use the following days for their repetition. To train your cases, you can use \"}<_components.a href=\"https://bestsiteever.net/zbll\">{\"bestsiteever.net/zbll\"}</_components.a>{\" and select the cases you are learning right now.\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[1].id}>{toc[1].value}</_components.h2>{\"\\n\"}<_components.p>{\"There are multiple sites where you can find ZBLL algorithms. Some of them are listed below:\"}</_components.p>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.a href=\"https://speedcubedb.com/a/ZBLL\">{\"SpeedCubeDB ZBLL\"}</_components.a>{\": big selection of algorithms, but the top algorithm is often not the best one\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1BiQZkCZvTDRlW6Y6jTBHXPPjZF9k55x8YJgXXs5nhCs/\">{\"Teri’s ZBLL\"}</_components.a>{\": really optimised algorithms, but getting the right fingertricks can be tricky. These algorithms require a lot of practice and might be riskier than you’d like.\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1-uwmZHf4vwJxFgeB3-TiF8MQ0RFSS30d5CUK96PoIwk/\">{\"Juju ZBLL\"}</_components.a>{\": good algorithms that are used by a world-class ZBLL user. Sometimes there are better algorithms available.\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://pepkin88.me/zbll-explorer/\">{\"ZBLL Explorer\"}</_components.a>{\": big selection of algorithms, better ranking than SpeedCubeDB’s, shows the relation between cases\"}</_components.li>{\"\\n\"}</_components.ul></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"AAAA,uBAAuB,GACvB,wBAAwB;;;;;;;;;;;AACxB;AAMA;;;AALO,MAAM,WAAW;IACtB,SAAS;IACT,YAAY;IACZ,aAAa;AACf;;AAEO,MAAM,aAAa;AAC1B,SAAS,OAAO,KAAK;IACnB,OAAO;QAAC;YACN,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;KAAE;AACJ;AACO,MAAM,MAAM,OAAO,CAAC;AAC3B,SAAS,kBAAkB,KAAK;IAC9B,MAAM,cAAc;QAClB,GAAG;QACH,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,GAAG;QACH,QAAQ;QACR,IAAI;QACJ,GAAG,IAAA,qIAAkB,GAAE;QACvB,GAAG,MAAM,UAAU;IACrB;IACA,qBAAO;;0BAAE,8OAAC,wIAAK;gBAAC,KAAI;gBAA4B,OAAO;gBAAK,QAAQ;gBAAK,KAAI;gBAAsC,KAAI;;;;;;YAAwH;0BAAK,8OAAC,YAAY,EAAE;0BAAE;;;;;;YAA+C;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAoI,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAA4D;;;;;;;YAAwF;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAyB,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAA+C;;;;;;;YAA6b;0BAAK,8OAAC,YAAY,EAAE;gBAAC,OAAM;;oBAAK;kCAAK,8OAAC,YAAY,EAAE;kCAAE;;;;;;oBAAwB;kCAAK,8OAAC,YAAY,EAAE;kCAAE;;;;;;oBAA+B;kCAAK,8OAAC,YAAY,EAAE;kCAAE;;;;;;oBAA6B;kCAAK,8OAAC,YAAY,EAAE;kCAAE;;;;;;oBAAsC;;;;;;;YAAuB;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAgD,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAA2C;kCAA+Q,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAiC;;;;;;oBAAyC;;;;;;;YAAqE;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAA+G;0BAAK,8OAAC,YAAY,EAAE;;oBAAE;kCAAK,8OAAC,YAAY,EAAE;;0CAAC,8OAAC,YAAY,CAAC;gCAAC,MAAK;0CAAkC;;;;;;4BAAoC;;;;;;;oBAAmG;kCAAK,8OAAC,YAAY,EAAE;;0CAAC,8OAAC,YAAY,CAAC;gCAAC,MAAK;0CAAwF;;;;;;4BAA+B;;;;;;;oBAAsL;kCAAK,8OAAC,YAAY,EAAE;;0CAAC,8OAAC,YAAY,CAAC;gCAAC,MAAK;0CAAwF;;;;;;4BAA6B;;;;;;;oBAAiI;kCAAK,8OAAC,YAAY,EAAE;;0CAAC,8OAAC,YAAY,CAAC;gCAAC,MAAK;0CAAsC;;;;;;4BAAiC;;;;;;;oBAAuH;;;;;;;;;AACvzG;uCACe","debugId":null}},
    {"offset": {"line": 430, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/big-cubes/_meta.js"],"sourcesContent":["export default {\n  meyer: 'Meyer',\n  yaupb: 'YauPB',\n  algs: 'More Ergonomic Algorithms'\n}"],"names":[],"mappings":";;;;uCAAe;IACb,OAAO;IACP,OAAO;IACP,MAAM;AACR","debugId":null}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/big-cubes/algs.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"More Ergonomic Algorithms\",\n  \"filePath\": \"content/big-cubes/algs.mdx\",\n  \"timestamp\": 1758384362296\n};\nexport const sourceCode = \"# More Ergonomic Algorithms\\nOn big cubes, algorithms with S-moves might be a problem. Since S-moves are the reason EO is so efficient, using only RUF algorithms makes the average movecount almost 3 moves higher. Especially for the cases where the DR edge is misoriented, it is recommended to do the S-move algorithms, even on 7x7. That said, some of the other cases are not too bad using only RUF. The RUF EO algorithms can be found [here](https://docs.google.com/spreadsheets/d/1fjuIZvBnhMOp90Ify5DWr_Yh3YS0ewuukODGb16kSoA/edit?usp=sharing). \\n\\nFor LXS, it is recommended to avoid using algorithms with D-, and S-moves. You can choose alternative solutions in the [regular LXS sheet](https://docs.google.com/spreadsheets/d/1P2DB0SyA1BrezYJ_g7RJ7_l32Ilxq7lLtr53zlG_TUU/).\";\nfunction useTOC(props) {\n  return [];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><_components.h1>{\"More Ergonomic Algorithms\"}</_components.h1>{\"\\n\"}<_components.p>{\"On big cubes, algorithms with S-moves might be a problem. Since S-moves are the reason EO is so efficient, using only RUF algorithms makes the average movecount almost 3 moves higher. Especially for the cases where the DR edge is misoriented, it is recommended to do the S-move algorithms, even on 7x7. That said, some of the other cases are not too bad using only RUF. The RUF EO algorithms can be found \"}<_components.a href=\"https://docs.google.com/spreadsheets/d/1fjuIZvBnhMOp90Ify5DWr_Yh3YS0ewuukODGb16kSoA/edit?usp=sharing\">{\"here\"}</_components.a>{\".\"}</_components.p>{\"\\n\"}<_components.p>{\"For LXS, it is recommended to avoid using algorithms with D-, and S-moves. You can choose alternative solutions in the \"}<_components.a href=\"https://docs.google.com/spreadsheets/d/1P2DB0SyA1BrezYJ_g7RJ7_l32Ilxq7lLtr53zlG_TUU/\">{\"regular LXS sheet\"}</_components.a>{\".\"}</_components.p></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"AAAA,uBAAuB,GACvB,wBAAwB;;;;;;;;;;;AACxB;;;AACO,MAAM,WAAW;IACtB,SAAS;IACT,YAAY;IACZ,aAAa;AACf;AACO,MAAM,aAAa;AAC1B,SAAS,OAAO,KAAK;IACnB,OAAO,EAAE;AACX;AACO,MAAM,MAAM,OAAO,CAAC;AAC3B,SAAS,kBAAkB,KAAK;IAC9B,MAAM,cAAc;QAClB,GAAG;QACH,IAAI;QACJ,GAAG;QACH,GAAG,IAAA,qIAAkB,GAAE;QACvB,GAAG,MAAM,UAAU;IACrB;IACA,qBAAO;;0BAAE,8OAAC,YAAY,EAAE;0BAAE;;;;;;YAA8C;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAwZ,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAwG;;;;;;oBAAwB;;;;;;;YAAqB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAA0H,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAwF;;;;;;oBAAqC;;;;;;;;;AACh8B;uCACe","debugId":null}},
    {"offset": {"line": 530, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/big-cubes/meyer.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"Meyer Method for 4x4+\",\n  \"filePath\": \"content/big-cubes/meyer.mdx\",\n  \"timestamp\": 1758384364147\n};\nimport {Steps, Callout} from 'nextra/components';\nimport Image from 'next/image';\nexport const sourceCode = \"import { Steps, Callout } from 'nextra/components'\\nimport Image from 'next/image'\\n\\n<Image src=\\\"/images/big-cubes/meyer/meyer.svg\\\" width={200} height={200} alt=\\\"Image of the Meyer Method on a 4x4x4\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&r=y-35x25&fc=ddddddddddddddddddddddddddddddddddddbdddbdddbdddwdddwdddwdddwdddddddoooooooooooo\\\"/>\\n# Meyer Method for 4x4+ \\nThe Meyer method was originally developped for solvers using Roux, but since both APB and Roux usually start with a 1x2x3 block, Meyer can be used with APB as well. This tutorial is explained using a 4x4, but Meyer is used on bigger puzzles as well.\\n\\n<Callout type=\\\"info\\\">\\n    This tutorial is written for people who can already solve a 4x4 using other methods.\\n</Callout>\\n\\n## Tutorial\\n<Steps>\\n    {<h3>Solve two opposite centers</h3>}\\n        <Image src=\\\"/images/big-cubes/meyer/two-centers.svg\\\" width={170} height={170} alt=\\\"Image of a 4x4x4 with the first two centers solved\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&co=10&fo=70&fc=dddddooddooddddddddddddddddddddddddddddddddddddddddddrrddrrddddddddddddddddddddddddddddddddddddd\\\"/>\\n        As the first step, **two opposite centers are solved**. One of these centers will be your L-face color for the 1x2x3 block. If you can only solve with a specific block color, make sure to choose the correct centers to solve here.\\n    {<h3>Create a 1x2x3 block on the bottom-left</h3>}\\n        <Image src=\\\"/images/big-cubes/meyer/1x2x3.svg\\\" width={170} height={170} alt=\\\"Image of a 4x4x4 with the 1x2x3 solved\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&co=20&fo=70&r=y-35x25&fc=dddddddddddddddddddddrrddrrdddddddddbdddbdddbdddwdddwdddwdddwdddddddoooooooooooodddddddgdddgdddg\\\"/>\\n        After creating the first two centers, you can **create a 1x2x3 block on the left side** of the cube. To achieve this, you can use block building. If you are struggling to find efficient solutions, try first pairing the DL dedge by bringing both wings to DF and then solving the dedge. Then you can attach two F2L pairs. You can think of the two pairs as regular pairs, just with one more piece.\\n    {<h3>Solve the remaining centers</h3>}\\n        <Image src=\\\"/images/big-cubes/meyer/centers.svg\\\" width={170} height={170} alt=\\\"Image of a 4x4x4 with the remaining centers solved\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&co=20&fo=70&r=y-35x25&fc=dddddbbddbbddddddddddrrddrrdddddddddbwwdbwwdbdddwdddwggdwggdwdddddddoooooooooooodddddyygdyygdddg\\\"/>\\n        Now, you can **solve the remaining centers** using R-, 2Rw-, 3Rw- and U-moves.\\n    {<h3>Pair the remaining wings</h3>}\\n        <Image src=\\\"/images/big-cubes/meyer/edges.svg\\\" width={170} height={170} alt=\\\"Image of a 4x4x4 with the remaining edges solved\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&co=20&fo=70&r=y-35x25&fc=yrrooggroggrryyoyggyrrrbrrrbwyygbbbgbyyybyyybwwrwggbwbbgwbbgwwwrbyyyoooooooooooogwworwwgrwwgwbbg\\\"/>\\n        To **pair the remaining wings**, you should first do a `y' x'`-rotation. Then you should first solve any dedge and put it into DF. Now you can pair the other edges using [3-2-3 edge pairing](https://www.speedsolving.com/wiki/index.php?title=Edge_pairing#3-2-3_edge_pairing) on 4x4 or [Freeslice](https://www.speedsolving.com/wiki/index.php?title=Edge_pairing#Freeslice_edge_pairing) on bigger cubes. \\n        <Callout type=\\\"warning\\\">\\n            If you insert pieces into back slots during edge pairing, make sure you place an unsolved corner at that slot using D-moves (for example by inserting an edge into BR using `D R' U' R D'` instead of `R' U' R`). **Otherwise you will destroy your 1x2x3!**\\n        </Callout>\\n    {<h3>Solve like a 3x3</h3>}\\n        Finally you can undo the `y' x'`-rotation and solve **the cube normally.** Your next step is solving the DF and DB edges to complete the 2x2x3.\\n\\n</Steps>\\n\\n### Dealing with Parity\\nFor cases where you do not recognize that you have parity (on 4x4 and one 6x6 case), you should solve OLL parity before solving edge orientation. In the other cases it should be solved immediately after pairing the wings.\\n\\nPLL parity should be done during the last layer. If you use OCLL + PLL, you should correct PLL parity before or after PLL, if you use ZBLL, you should correct it before or after ZBLL.\\n\\n## Learning more Optimized Algorithms\\nTips on which algorithms to use on big cubes can be found [here](/big-cubes/algs.mdx).\";\nfunction useTOC(props) {\n  return [{\n    value: \"Tutorial\",\n    id: \"tutorial\",\n    depth: 2\n  }, {\n    value: \"Dealing with Parity\",\n    id: \"dealing-with-parity\",\n    depth: 3\n  }, {\n    value: \"Learning more Optimized Algorithms\",\n    id: \"learning-more-optimized-algorithms\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/big-cubes/meyer/meyer.svg\" width={200} height={200} alt=\"Image of the Meyer Method on a 4x4x4\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;r=y-35x25&amp;fc=ddddddddddddddddddddddddddddddddddddbdddbdddbdddwdddwdddwdddwdddddddoooooooooooo\" />{\"\\n\"}<_components.h1>{\"Meyer Method for 4x4+\"}</_components.h1>{\"\\n\"}<_components.p>{\"The Meyer method was originally developped for solvers using Roux, but since both APB and Roux usually start with a 1x2x3 block, Meyer can be used with APB as well. This tutorial is explained using a 4x4, but Meyer is used on bigger puzzles as well.\"}</_components.p>{\"\\n\"}<Callout type=\"info\"><_components.p>{\"This tutorial is written for people who can already solve a 4x4 using other methods.\"}</_components.p></Callout>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<Steps>{<h3>Solve two opposite centers</h3>}<Image src=\"/images/big-cubes/meyer/two-centers.svg\" width={170} height={170} alt=\"Image of a 4x4x4 with the first two centers solved\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;co=10&amp;fo=70&amp;fc=dddddooddooddddddddddddddddddddddddddddddddddddddddddrrddrrddddddddddddddddddddddddddddddddddddd\" /><_components.p>{\"As the first step, \"}<_components.strong>{\"two opposite centers are solved\"}</_components.strong>{\". One of these centers will be your L-face color for the 1x2x3 block. If you can only solve with a specific block color, make sure to choose the correct centers to solve here.\"}</_components.p>{<h3>Create a 1x2x3 block on the bottom-left</h3>}<Image src=\"/images/big-cubes/meyer/1x2x3.svg\" width={170} height={170} alt=\"Image of a 4x4x4 with the 1x2x3 solved\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;co=20&amp;fo=70&amp;r=y-35x25&amp;fc=dddddddddddddddddddddrrddrrdddddddddbdddbdddbdddwdddwdddwdddwdddddddoooooooooooodddddddgdddgdddg\" /><_components.p>{\"After creating the first two centers, you can \"}<_components.strong>{\"create a 1x2x3 block on the left side\"}</_components.strong>{\" of the cube. To achieve this, you can use block building. If you are struggling to find efficient solutions, try first pairing the DL dedge by bringing both wings to DF and then solving the dedge. Then you can attach two F2L pairs. You can think of the two pairs as regular pairs, just with one more piece.\"}</_components.p>{<h3>Solve the remaining centers</h3>}<Image src=\"/images/big-cubes/meyer/centers.svg\" width={170} height={170} alt=\"Image of a 4x4x4 with the remaining centers solved\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;co=20&amp;fo=70&amp;r=y-35x25&amp;fc=dddddbbddbbddddddddddrrddrrdddddddddbwwdbwwdbdddwdddwggdwggdwdddddddoooooooooooodddddyygdyygdddg\" /><_components.p>{\"Now, you can \"}<_components.strong>{\"solve the remaining centers\"}</_components.strong>{\" using R-, 2Rw-, 3Rw- and U-moves.\"}</_components.p>{<h3>Pair the remaining wings</h3>}<Image src=\"/images/big-cubes/meyer/edges.svg\" width={170} height={170} alt=\"Image of a 4x4x4 with the remaining edges solved\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;co=20&amp;fo=70&amp;r=y-35x25&amp;fc=yrrooggroggrryyoyggyrrrbrrrbwyygbbbgbyyybyyybwwrwggbwbbgwbbgwwwrbyyyoooooooooooogwworwwgrwwgwbbg\" /><_components.p>{\"To \"}<_components.strong>{\"pair the remaining wings\"}</_components.strong>{\", you should first do a \"}<_components.code>{\"y' x'\"}</_components.code>{\"-rotation. Then you should first solve any dedge and put it into DF. Now you can pair the other edges using \"}<_components.a href=\"https://www.speedsolving.com/wiki/index.php?title=Edge_pairing#3-2-3_edge_pairing\">{\"3-2-3 edge pairing\"}</_components.a>{\" on 4x4 or \"}<_components.a href=\"https://www.speedsolving.com/wiki/index.php?title=Edge_pairing#Freeslice_edge_pairing\">{\"Freeslice\"}</_components.a>{\" on bigger cubes.\"}</_components.p><Callout type=\"warning\"><_components.p>{\"If you insert pieces into back slots during edge pairing, make sure you place an unsolved corner at that slot using D-moves (for example by inserting an edge into BR using \"}<_components.code>{\"D R' U' R D'\"}</_components.code>{\" instead of \"}<_components.code>{\"R' U' R\"}</_components.code>{\"). \"}<_components.strong>{\"Otherwise you will destroy your 1x2x3!\"}</_components.strong></_components.p></Callout>{<h3>Solve like a 3x3</h3>}<_components.p>{\"Finally you can undo the \"}<_components.code>{\"y' x'\"}</_components.code>{\"-rotation and solve \"}<_components.strong>{\"the cube normally.\"}</_components.strong>{\" Your next step is solving the DF and DB edges to complete the 2x2x3.\"}</_components.p></Steps>{\"\\n\"}<_components.h3 id={toc[1].id}>{toc[1].value}</_components.h3>{\"\\n\"}<_components.p>{\"For cases where you do not recognize that you have parity (on 4x4 and one 6x6 case), you should solve OLL parity before solving edge orientation. In the other cases it should be solved immediately after pairing the wings.\"}</_components.p>{\"\\n\"}<_components.p>{\"PLL parity should be done during the last layer. If you use OCLL + PLL, you should correct PLL parity before or after PLL, if you use ZBLL, you should correct it before or after ZBLL.\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[2].id}>{toc[2].value}</_components.h2>{\"\\n\"}<_components.p>{\"Tips on which algorithms to use on big cubes can be found \"}<_components.a href=\"/big-cubes/algs\">{\"here\"}</_components.a>{\".\"}</_components.p></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 947, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/big-cubes/yaupb.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"YauPB for 4x4+\",\n  \"filePath\": \"content/big-cubes/yaupb.mdx\",\n  \"timestamp\": 1758384364889\n};\nimport {Steps, Callout} from 'nextra/components';\nimport Image from 'next/image';\nexport const sourceCode = \"import { Steps, Callout } from 'nextra/components'\\nimport Image from 'next/image'\\n\\n<Image src=\\\"/images/big-cubes/yaupb/yaupb.svg\\\" width={200} height={200} alt=\\\"Image of YauPB on a 4x4x4\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&r=y-35x25&fc=dddddddddddddddddddddddddddddddddddddbbddbbddbbddwwdwwwdwwwddwwddddddooddooddood\\\"/>\\n# YauPB for 4x4+\\nYauPB is the most similar to regular Yau with CFOP. Since you always have to solve your 2x2x3 by first solving three cross pieces and then two F2L pairs, this is not really the recommended method. In most cases, [Meyer](/big-cubes/meyer.mdx) will be better. What you can do is choosing to do YauPB when you see a very easy white or yellow center (if those are your U/F-colors). In that case, the slightly slower 2x2x3 will be worth it. This tutorial is explained using 4x4, but YauPB can be used on bigger cubes as well.\\n\\n<Callout type=\\\"info\\\">\\n    This tutorial is written for people who can already solve a 4x4 using other methods.\\n</Callout>\\n\\n## Tutorial\\n<Steps>\\n    {<h3>Solve two opposite centers</h3>}\\n        <Image src=\\\"/images/big-cubes/yaupb/two-centers.svg\\\" width={170} height={170} alt=\\\"Image of a 4x4x4 with the first two centers solved\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&co=10&fo=70&fc=dddddwwddwwddddddddddddddddddddddddddddddddddddddddddyyddyyddddddddddddddddddddddddddddddddddddd\\\"/>\\n        As the first step, **two opposite centers are solved**. One of these centers will be your D-face color for the 2x2x3 block. If you can only solve with a specific block color, make sure to choose the correct centers to solve here.\\n    {<h3>Solve three cross pieces</h3>}\\n        <Image src=\\\"/images/big-cubes/yaupb/three-cross-pieces.svg\\\" width={170} height={170} alt=\\\"Image of a 4x4x4 with three cross pieces solved\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&co=10&fo=70&r=y-35x25&fc=dddddyyddyyddddddddddddddddddddddddddddddddddbbddwwdwwwdwwwddwwddddddddddddddooddddddddddddddggd\\\"/>\\n        Next, you can **solve three cross edges** by connecting wings in the E slices. Make sure you put the cross pieces in the correct order.\\n    {<h3>Solve the remaining centers</h3>}\\n        <Image src=\\\"/images/big-cubes/yaupb/centers.svg\\\" width={170} height={170} alt=\\\"Image of a 4x4x4 with the remaining centers solved\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&co=10&fo=70&r=y-35x25&fc=dddddrrddrrddddddddddyyddyydddddddddgggdgggdddddddddooodooodddddddddwwwwwwwwdwwddddddbbbdbbbdddd\\\"/>\\n        After having solved the three cross pieces, you can hold them in the bottom left with the white side facing left. Then, you can **solve the remaining centers** using R-, 2Rw-, 3Rw- and U-moves.\\n    {<h3>Solve the remaining edges</h3>}\\n        <Image src=\\\"/images/big-cubes/yaupb/edges.svg\\\" width={170} height={170} alt=\\\"Image of a 4x4x4 with the remaining edges solved\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&bg=t&pzl=4&co=10&fo=70&r=y-35x25&fc=ybbwrrrorrroryywryyoyyyryyyrbggyyrrgggggggggoyyrbbbyoooooooowrroowwgwwwwwwwwrwwwgooggbbbgbbbbbbb\\\"/>\\n        To **pair the remaining wings**, you should first do a `y' x'`-rotation. Then you should first solve any dedge and put it into DF. Now you can pair the other edges using [3-2-3 edge pairing](https://www.speedsolving.com/wiki/index.php?title=Edge_pairing#3-2-3_edge_pairing) on 4x4 or [Freeslice](https://www.speedsolving.com/wiki/index.php?title=Edge_pairing#Freeslice_edge_pairing) on bigger cubes. \\n    {<h3>Solve like a 3x3</h3>}\\n        Finally you can undo the `y' x'`-rotation and solve **the cube normally.** Next, you must solve the F2L pairs on the left side to complete the 2x2x3.\\n\\n</Steps>\\n\\n### Dealing with Parity\\nFor cases where you do not recognize that you have parity (on 4x4 and one 6x6 case), you should solve OLL parity before solving edge orientation. In the other cases it should be solved immediately after pairing the wings.\\n\\nPLL parity should be done during the last layer. If you use OCLL + PLL, you should correct PLL parity before or after PLL, if you use ZBLL, you should correct it before or after ZBLL.\\n\\n## Learning more Optimized Algorithms\\nTips on which algorithms to use on big cubes can be found [here](/big-cubes/algs.mdx).\";\nfunction useTOC(props) {\n  return [{\n    value: \"Tutorial\",\n    id: \"tutorial\",\n    depth: 2\n  }, {\n    value: \"Dealing with Parity\",\n    id: \"dealing-with-parity\",\n    depth: 3\n  }, {\n    value: \"Learning more Optimized Algorithms\",\n    id: \"learning-more-optimized-algorithms\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/big-cubes/yaupb/yaupb.svg\" width={200} height={200} alt=\"Image of YauPB on a 4x4x4\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;r=y-35x25&amp;fc=dddddddddddddddddddddddddddddddddddddbbddbbddbbddwwdwwwdwwwddwwddddddooddooddood\" />{\"\\n\"}<_components.h1>{\"YauPB for 4x4+\"}</_components.h1>{\"\\n\"}<_components.p>{\"YauPB is the most similar to regular Yau with CFOP. Since you always have to solve your 2x2x3 by first solving three cross pieces and then two F2L pairs, this is not really the recommended method. In most cases, \"}<_components.a href=\"/big-cubes/meyer\">{\"Meyer\"}</_components.a>{\" will be better. What you can do is choosing to do YauPB when you see a very easy white or yellow center (if those are your U/F-colors). In that case, the slightly slower 2x2x3 will be worth it. This tutorial is explained using 4x4, but YauPB can be used on bigger cubes as well.\"}</_components.p>{\"\\n\"}<Callout type=\"info\"><_components.p>{\"This tutorial is written for people who can already solve a 4x4 using other methods.\"}</_components.p></Callout>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<Steps>{<h3>Solve two opposite centers</h3>}<Image src=\"/images/big-cubes/yaupb/two-centers.svg\" width={170} height={170} alt=\"Image of a 4x4x4 with the first two centers solved\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;co=10&amp;fo=70&amp;fc=dddddwwddwwddddddddddddddddddddddddddddddddddddddddddyyddyyddddddddddddddddddddddddddddddddddddd\" /><_components.p>{\"As the first step, \"}<_components.strong>{\"two opposite centers are solved\"}</_components.strong>{\". One of these centers will be your D-face color for the 2x2x3 block. If you can only solve with a specific block color, make sure to choose the correct centers to solve here.\"}</_components.p>{<h3>Solve three cross pieces</h3>}<Image src=\"/images/big-cubes/yaupb/three-cross-pieces.svg\" width={170} height={170} alt=\"Image of a 4x4x4 with three cross pieces solved\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;co=10&amp;fo=70&amp;r=y-35x25&amp;fc=dddddyyddyyddddddddddddddddddddddddddddddddddbbddwwdwwwdwwwddwwddddddddddddddooddddddddddddddggd\" /><_components.p>{\"Next, you can \"}<_components.strong>{\"solve three cross edges\"}</_components.strong>{\" by connecting wings in the E slices. Make sure you put the cross pieces in the correct order.\"}</_components.p>{<h3>Solve the remaining centers</h3>}<Image src=\"/images/big-cubes/yaupb/centers.svg\" width={170} height={170} alt=\"Image of a 4x4x4 with the remaining centers solved\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;co=10&amp;fo=70&amp;r=y-35x25&amp;fc=dddddrrddrrddddddddddyyddyydddddddddgggdgggdddddddddooodooodddddddddwwwwwwwwdwwddddddbbbdbbbdddd\" /><_components.p>{\"After having solved the three cross pieces, you can hold them in the bottom left with the white side facing left. Then, you can \"}<_components.strong>{\"solve the remaining centers\"}</_components.strong>{\" using R-, 2Rw-, 3Rw- and U-moves.\"}</_components.p>{<h3>Solve the remaining edges</h3>}<Image src=\"/images/big-cubes/yaupb/edges.svg\" width={170} height={170} alt=\"Image of a 4x4x4 with the remaining edges solved\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;bg=t&amp;pzl=4&amp;co=10&amp;fo=70&amp;r=y-35x25&amp;fc=ybbwrrrorrroryywryyoyyyryyyrbggyyrrgggggggggoyyrbbbyoooooooowrroowwgwwwwwwwwrwwwgooggbbbgbbbbbbb\" /><_components.p>{\"To \"}<_components.strong>{\"pair the remaining wings\"}</_components.strong>{\", you should first do a \"}<_components.code>{\"y' x'\"}</_components.code>{\"-rotation. Then you should first solve any dedge and put it into DF. Now you can pair the other edges using \"}<_components.a href=\"https://www.speedsolving.com/wiki/index.php?title=Edge_pairing#3-2-3_edge_pairing\">{\"3-2-3 edge pairing\"}</_components.a>{\" on 4x4 or \"}<_components.a href=\"https://www.speedsolving.com/wiki/index.php?title=Edge_pairing#Freeslice_edge_pairing\">{\"Freeslice\"}</_components.a>{\" on bigger cubes.\"}</_components.p>{<h3>Solve like a 3x3</h3>}<_components.p>{\"Finally you can undo the \"}<_components.code>{\"y' x'\"}</_components.code>{\"-rotation and solve \"}<_components.strong>{\"the cube normally.\"}</_components.strong>{\" Next, you must solve the F2L pairs on the left side to complete the 2x2x3.\"}</_components.p></Steps>{\"\\n\"}<_components.h3 id={toc[1].id}>{toc[1].value}</_components.h3>{\"\\n\"}<_components.p>{\"For cases where you do not recognize that you have parity (on 4x4 and one 6x6 case), you should solve OLL parity before solving edge orientation. In the other cases it should be solved immediately after pairing the wings.\"}</_components.p>{\"\\n\"}<_components.p>{\"PLL parity should be done during the last layer. If you use OCLL + PLL, you should correct PLL parity before or after PLL, if you use ZBLL, you should correct it before or after ZBLL.\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[2].id}>{toc[2].value}</_components.h2>{\"\\n\"}<_components.p>{\"Tips on which algorithms to use on big cubes can be found \"}<_components.a href=\"/big-cubes/algs\">{\"here\"}</_components.a>{\".\"}</_components.p></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1336, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/tutorial/223.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"1. Solving a 2x2x3\",\n  \"filePath\": \"content/tutorial/223.mdx\",\n  \"timestamp\": 1758384365854\n};\nimport Image from 'next/image';\nimport {Callout, Tabs, Steps} from 'nextra/components';\nexport const sourceCode = \"import Image from 'next/image'\\nimport { Callout, Tabs, Steps } from 'nextra/components'\\n\\n<Image src=\\\"/images/tutorial/223.svg\\\" width={200} height={200} alt=\\\"Image of a cube with the 2x2x3 block done\\\"/>\\n# 1. Solving a 2x2x3\\n<Callout type=\\\"info\\\">\\n    For simplicity purposes, this tutorial will explain the method using **white on the bottom face**, even though at a higher level, solvers should be able to solve with either white or yellow on the bottom.\\n</Callout>\\n\\n## Introduction\\nThe first step of the APB method is **building a 2x2x3 block on the bottom-left side of the cube**. This can be achieved through various ways and it is ultimately up to the solver to decide on which option to choose for a particular scramble. Since this is by far the step with the most freedom, there are a lot of techniques required to consistently achieve a good movecount. Below I will show some of the most useful and consistent methods of creating the 2x2x3.\\n<Callout type=\\\"important\\\">\\n    Unlike in regular Petrus, the 2x2x3 in APB is always solved on the bottom-left.\\n</Callout>\\n\\n<Callout type=\\\"info\\\">\\n    When explaining methods making use of blockbuilding, **Block Referencing** is very useful to name a certain set of pieces. In block referencing, a combination of layers, for example *DF*, refers to those pieces that are in all of those layers, in this case the *DFL*, *DF*, and *DFR* pieces. This can be done with wide moves and slices as well. *dM* would therefore refer to the *DF* and *DB* edges and the *B*, *D*, and *F* centers.\\n    [See more on Athefre's website](https://sites.google.com/site/athefre/steps-concepts/nbrs)\\n</Callout>\\n\\n## 1x2x3 → 2x2x3\\n<Image src=\\\"/images/tutorial/123-223.svg\\\" width={200} height={200} alt=\\\"Image of the 2x2x3 being solved using the 1x2x3 to 2x2x3 method\\\"/>\\nFirst creating a **Roux-style 1x2x3** block and then adding the **DF and DB edges** is probably the most consistent way of solving the 2x2x3. On most scrambles, this way of making your 2x2x3 leads to an efficient solution.\\n\\n### Creating the 1x2x3\\nLike with the whole 2x2x3, the 1x2x3 can also be created through various techniques. To figure out new techniques, it is recommended you **experiment a little on your own** as well. Below are some possible methods to create the 1x2x3.\\n\\n<Tabs items={['General Blockbuilding', 'Line', 'F2L-Style']}>\\n    <Tabs.Tab>\\n        <Image src=\\\"/images/tutorial/other-blockbuilding-123.svg\\\" width={120} height={120} alt=\\\"Image of the 1x2x3 being solved using other blockbuilding\\\"/>\\n        Various blockbuilding techniques can be used to build the 1x2x3. If the scramble, for example, already provides the block at *Db*, the solver could first solve the *Eb* edge and center in relation to each other and then insert them. Finally, they would create and solve the pair belonging in *dF*. On many scrambles, such blockbuilding techniques lead to the best solutions.\\n        #### Example Solution\\n        <twisty-player\\n            id=\\\"blockbuilding-viewer\\\"\\n            experimentalStickeringMaskOrbits=\\\"EDGES:III-IIIII-I-,CORNERS:II--IIII,CENTERS:I-I-II\\\"\\n            experimental-setup-anchor=\\\"end\\\"\\n            experimental-setup-alg=\\\"x2\\\"\\n            alg=\\\"r D' r' U R2 B'\\\"\\n            hint-facelets=\\\"none\\\"\\n            camera-latitude=\\\"-35\\\"\\n            camera-longitude=\\\"-25\\\"\\n            color-scheme=\\\"dark\\\"\\n        />\\n        <twisty-alg-viewer for=\\\"blockbuilding-viewer\\\"/>\\n    </Tabs.Tab>\\n    <Tabs.Tab>\\n        <Image src=\\\"/images/tutorial/line-123.svg\\\" width={120} height={120} alt=\\\"Image of the 1x2x3 being solved using the line method\\\"/>\\n        A 1x2x3-block can also be created using two 1x1x3 lines. These can be made in any order. If the scramble allows for it or even comes with a pre-built line, this method can lead to very efficient solutions.\\n        #### Example Solution\\n        <twisty-player\\n            id=\\\"line-viewer\\\"\\n            experimentalStickeringMaskOrbits=\\\"EDGES:III-IIIII-I-,CORNERS:II--IIII,CENTERS:I-I-II\\\"\\n            experimental-setup-anchor=\\\"end\\\"\\n            experimental-setup-alg=\\\"x2\\\"\\n            alg=\\\"U' R' U' R D2 U R U R' D'\\\"\\n            hint-facelets=\\\"none\\\"\\n            camera-latitude=\\\"-35\\\"\\n            camera-longitude=\\\"-25\\\"\\n            color-scheme=\\\"dark\\\"\\n        />\\n        <twisty-alg-viewer for=\\\"line-viewer\\\"/>\\n    </Tabs.Tab>\\n    <Tabs.Tab>\\n        <Image src=\\\"/images/tutorial/f2l-123.svg\\\" width={120} height={120} alt=\\\"Image of the 1x2x3 being solved using an F2L-style method\\\"/>\\n        It is possible to create the 1x2x3 using an F2L-style approach by first solving the DL edge and then creating and inserting the two left F2L pairs. It can sometimes be a bit hard to find efficient solutions using this method, so you should always be able to solve with other techniques as well.\\n        #### Example Solution\\n        <twisty-player\\n            id=\\\"f2l-viewer\\\"\\n            experimentalStickeringMaskOrbits=\\\"EDGES:III-IIIII-I-,CORNERS:II--IIII,CENTERS:I-I-II\\\"\\n            experimental-setup-anchor=\\\"end\\\"\\n            experimental-setup-alg=\\\"x2\\\"\\n            alg=\\\"D' r' R2 F r' U2 r U R2 B'\\\"\\n            hint-facelets=\\\"none\\\"\\n            camera-latitude=\\\"-35\\\"\\n            camera-longitude=\\\"-25\\\"\\n            color-scheme=\\\"dark\\\"\\n        />\\n        <twisty-alg-viewer for=\\\"f2l-viewer\\\"/>\\n    </Tabs.Tab>\\n</Tabs>\\n\\n### Solving the DFDB Edges\\nAfter having created the 1x2x3 block in dL, you can **extend it to a 2x2x3** by solving the edges at DF and DB. This can be achieved in two main ways: You can either solve each of them seperately by placing them in the U-layer an then inserting them by doing `r U' r'`, `r U2 r'`, `r' U r`, or `r' U2 r` depending on the situation. The other option is creating a line consisting of the two edges and the white center in the U-layer and then inserting it by doing an `r2`-move. This method often is more efficient, especially when the edges are oriented (e.g. have their white side on the U-face, front-right, back-right or D-face).\\n\\n#### Examples\\n<twisty-player\\n    id=\\\"dfdb1-viewer\\\"\\n    experimentalStickeringMaskOrbits=\\\"EDGES:-I-DIIIIIDID,CORNERS:IIDDIIII,CENTERS:-D----\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2\\\"\\n    alg=\\\"U r U' r' U r' U r\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"35\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/>\\n<twisty-alg-viewer for=\\\"dfdb1-viewer\\\"/>\\n<twisty-player\\n    id=\\\"dfdb2-viewer\\\"\\n    experimentalStickeringMaskOrbits=\\\"EDGES:-I-DIIIIIDID,CORNERS:IIDDIIII,CENTERS:-D----\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2\\\"\\n    alg=\\\"R' U' R M' U r2\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"35\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/>\\n<twisty-alg-viewer for=\\\"dfdb2-viewer\\\"/>\\n\\n<Callout type=\\\"default\\\">\\n    Instead of creating the 1x2x3 in dL and then solving the DF and DB edges, you can also create the 1x2x3 in Dl and then solve the FL and BL edges.\\n</Callout>\\n\\n## 2x2x2 → 2x2x3\\n<Image src=\\\"/images/tutorial/222-223.svg\\\" width={200} height={200} alt=\\\"Image of the 2x2x3 being solved using the 2x2x2 to 2x2x3 method\\\"/>\\nAn alternative way to solve the 2x2x3 is first creating a 2x2x2 in *dbl* or *dlf* and then extending it by attaching a second 1x1x2 block in *dlF* or *dBl*. This is a very versatile technique too, but it sometimes leads to awkward fingertricks with `F2`- or `B2`-moves.\\n\\n### Creating the 2x2x2\\n<Image src=\\\"/images/tutorial/222-slab.svg\\\" width={120} height={120} alt=\\\"Image of the 2x2x2 being solved using the 'slab'-technique\\\"/>\\nOne way of creating a 2x2x2 block is by creating a 1x2x2 block in *Dbl* or *Dlf*. You can then add an edge with the correct two center pieces, creating a 2x2x2. Of course it is also possible to first create a block in *Ebl* or *Elf* and then adding the other block. As there is a lot of freedom, we recommend you experiment a bit on your own.\\n\\n### Extending to a 2x2x3\\n<Image src=\\\"/images/tutorial/222-223.svg\\\" width={120} height={120} alt=\\\"Image of the 2x2x2 being extended to a 2x2x3\\\"/>\\nTo then add another 1x2x2, you can again make use of multiple strategies. Often, you would connect one of the two edges to the center and then attach a corner-edge pair using a sequence like `R' F R` or `L F' L'`. You might even solve the two edges first and then solve the corner using a keyhole-style insert like `D R U R' D'`.\\n\\n## Three Cross Pieces + 2 F2L Pairs\\n<Image src=\\\"/images/tutorial/cross_2f2l.svg\\\" width={200} height={200} alt=\\\"Image of the 2x2x3 being solved using a cross+F2L style method\\\"/>\\n<Callout type=\\\"error\\\">\\n    Even though you might be tempted to always solve your 2x2x3 like this, this is **NOT** the most efficient method and is only useful on very specific scrambles.\\n</Callout>\\nOn some scrambles, solving the 2x2x3 like F2L in CFOP, except without any of the pieces in the R-layer, is the fastest method. Even though the movecount might not be too low, this method does allow for high TPS. Keep in mind this is really only recommended if:\\n- **at least two cross pieces are solved or solvable in one move** and\\n- **at least one of the two edges belonging into FL and BL is oriented** (e.g. has its front/back color on the U-face, D-face if it is in those layers or the front/back face if it is in the E-layer).\";\nfunction useTOC(props) {\n  return [{\n    value: \"Introduction\",\n    id: \"introduction\",\n    depth: 2\n  }, {\n    value: \"1x2x3 → 2x2x3\",\n    id: \"1x2x3--2x2x3\",\n    depth: 2\n  }, {\n    value: \"Creating the 1x2x3\",\n    id: \"creating-the-1x2x3\",\n    depth: 3\n  }, {\n    value: \"Example Solution\",\n    id: \"example-solution\",\n    depth: 4\n  }, {\n    value: \"Example Solution\",\n    id: \"example-solution-1\",\n    depth: 4\n  }, {\n    value: \"Example Solution\",\n    id: \"example-solution-2\",\n    depth: 4\n  }, {\n    value: \"Solving the DFDB Edges\",\n    id: \"solving-the-dfdb-edges\",\n    depth: 3\n  }, {\n    value: \"Examples\",\n    id: \"examples\",\n    depth: 4\n  }, {\n    value: \"2x2x2 → 2x2x3\",\n    id: \"2x2x2--2x2x3\",\n    depth: 2\n  }, {\n    value: \"Creating the 2x2x2\",\n    id: \"creating-the-2x2x2\",\n    depth: 3\n  }, {\n    value: \"Extending to a 2x2x3\",\n    id: \"extending-to-a-2x2x3\",\n    depth: 3\n  }, {\n    value: \"Three Cross Pieces + 2 F2L Pairs\",\n    id: \"three-cross-pieces--2-f2l-pairs\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  if (!Tabs) _missingMdxReference(\"Tabs\", false, \"29:5-45:16\");\n  if (!Tabs.Tab) _missingMdxReference(\"Tabs.Tab\", true, \"29:5-45:16\");\n  return <><Image src=\"/images/tutorial/223.svg\" width={200} height={200} alt=\"Image of a cube with the 2x2x3 block done\" />{\"\\n\"}<_components.h1>{\"1. Solving a 2x2x3\"}</_components.h1>{\"\\n\"}<Callout type=\"info\"><_components.p>{\"For simplicity purposes, this tutorial will explain the method using \"}<_components.strong>{\"white on the bottom face\"}</_components.strong>{\", even though at a higher level, solvers should be able to solve with either white or yellow on the bottom.\"}</_components.p></Callout>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<_components.p>{\"The first step of the APB method is \"}<_components.strong>{\"building a 2x2x3 block on the bottom-left side of the cube\"}</_components.strong>{\". This can be achieved through various ways and it is ultimately up to the solver to decide on which option to choose for a particular scramble. Since this is by far the step with the most freedom, there are a lot of techniques required to consistently achieve a good movecount. Below I will show some of the most useful and consistent methods of creating the 2x2x3.\"}</_components.p>{\"\\n\"}<Callout type=\"important\"><_components.p>{\"Unlike in regular Petrus, the 2x2x3 in APB is always solved on the bottom-left.\"}</_components.p></Callout>{\"\\n\"}<Callout type=\"info\"><_components.p>{\"When explaining methods making use of blockbuilding, \"}<_components.strong>{\"Block Referencing\"}</_components.strong>{\" is very useful to name a certain set of pieces. In block referencing, a combination of layers, for example \"}<_components.em>{\"DF\"}</_components.em>{\", refers to those pieces that are in all of those layers, in this case the \"}<_components.em>{\"DFL\"}</_components.em>{\", \"}<_components.em>{\"DF\"}</_components.em>{\", and \"}<_components.em>{\"DFR\"}</_components.em>{\" pieces. This can be done with wide moves and slices as well. \"}<_components.em>{\"dM\"}</_components.em>{\" would therefore refer to the \"}<_components.em>{\"DF\"}</_components.em>{\" and \"}<_components.em>{\"DB\"}</_components.em>{\" edges and the \"}<_components.em>{\"B\"}</_components.em>{\", \"}<_components.em>{\"D\"}</_components.em>{\", and \"}<_components.em>{\"F\"}</_components.em>{\" centers.\\n\"}<_components.a href=\"https://sites.google.com/site/athefre/steps-concepts/nbrs\">{\"See more on Athefre’s website\"}</_components.a></_components.p></Callout>{\"\\n\"}<_components.h2 id={toc[1].id}>{toc[1].value}</_components.h2>{\"\\n\"}<Image src=\"/images/tutorial/123-223.svg\" width={200} height={200} alt=\"Image of the 2x2x3 being solved using the 1x2x3 to 2x2x3 method\" />{\"\\n\"}<_components.p>{\"First creating a \"}<_components.strong>{\"Roux-style 1x2x3\"}</_components.strong>{\" block and then adding the \"}<_components.strong>{\"DF and DB edges\"}</_components.strong>{\" is probably the most consistent way of solving the 2x2x3. On most scrambles, this way of making your 2x2x3 leads to an efficient solution.\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[2].id}>{toc[2].value}</_components.h3>{\"\\n\"}<_components.p>{\"Like with the whole 2x2x3, the 1x2x3 can also be created through various techniques. To figure out new techniques, it is recommended you \"}<_components.strong>{\"experiment a little on your own\"}</_components.strong>{\" as well. Below are some possible methods to create the 1x2x3.\"}</_components.p>{\"\\n\"}<Tabs items={['General Blockbuilding', 'Line', 'F2L-Style']}><Tabs.Tab><h3 id=\"general-blockbuilding\" style={{\n    visibility: \"hidden\",\n    width: 0,\n    height: 0\n  }}>{\"General Blockbuilding\"}</h3><Image src=\"/images/tutorial/other-blockbuilding-123.svg\" width={120} height={120} alt=\"Image of the 1x2x3 being solved using other blockbuilding\" /><_components.p>{\"Various blockbuilding techniques can be used to build the 1x2x3. If the scramble, for example, already provides the block at \"}<_components.em>{\"Db\"}</_components.em>{\", the solver could first solve the \"}<_components.em>{\"Eb\"}</_components.em>{\" edge and center in relation to each other and then insert them. Finally, they would create and solve the pair belonging in \"}<_components.em>{\"dF\"}</_components.em>{\". On many scrambles, such blockbuilding techniques lead to the best solutions.\"}</_components.p><_components.h4 id={toc[3].id}>{toc[3].value}</_components.h4><twisty-player id=\"blockbuilding-viewer\" experimentalStickeringMaskOrbits=\"EDGES:III-IIIII-I-,CORNERS:II--IIII,CENTERS:I-I-II\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"r D' r' U R2 B'\" hint-facelets=\"none\" camera-latitude=\"-35\" camera-longitude=\"-25\" color-scheme=\"dark\" /><twisty-alg-viewer for=\"blockbuilding-viewer\" /></Tabs.Tab><Tabs.Tab><h3 id=\"line\" style={{\n    visibility: \"hidden\",\n    width: 0,\n    height: 0\n  }}>{\"Line\"}</h3><Image src=\"/images/tutorial/line-123.svg\" width={120} height={120} alt=\"Image of the 1x2x3 being solved using the line method\" /><_components.p>{\"A 1x2x3-block can also be created using two 1x1x3 lines. These can be made in any order. If the scramble allows for it or even comes with a pre-built line, this method can lead to very efficient solutions.\"}</_components.p><_components.h4 id={toc[4].id}>{toc[4].value}</_components.h4><twisty-player id=\"line-viewer\" experimentalStickeringMaskOrbits=\"EDGES:III-IIIII-I-,CORNERS:II--IIII,CENTERS:I-I-II\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"U' R' U' R D2 U R U R' D'\" hint-facelets=\"none\" camera-latitude=\"-35\" camera-longitude=\"-25\" color-scheme=\"dark\" /><twisty-alg-viewer for=\"line-viewer\" /></Tabs.Tab><Tabs.Tab><h3 id=\"f2l-style\" style={{\n    visibility: \"hidden\",\n    width: 0,\n    height: 0\n  }}>{\"F2L-Style\"}</h3><Image src=\"/images/tutorial/f2l-123.svg\" width={120} height={120} alt=\"Image of the 1x2x3 being solved using an F2L-style method\" /><_components.p>{\"It is possible to create the 1x2x3 using an F2L-style approach by first solving the DL edge and then creating and inserting the two left F2L pairs. It can sometimes be a bit hard to find efficient solutions using this method, so you should always be able to solve with other techniques as well.\"}</_components.p><_components.h4 id={toc[5].id}>{toc[5].value}</_components.h4><twisty-player id=\"f2l-viewer\" experimentalStickeringMaskOrbits=\"EDGES:III-IIIII-I-,CORNERS:II--IIII,CENTERS:I-I-II\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"D' r' R2 F r' U2 r U R2 B'\" hint-facelets=\"none\" camera-latitude=\"-35\" camera-longitude=\"-25\" color-scheme=\"dark\" /><twisty-alg-viewer for=\"f2l-viewer\" /></Tabs.Tab></Tabs>{\"\\n\"}<_components.h3 id={toc[6].id}>{toc[6].value}</_components.h3>{\"\\n\"}<_components.p>{\"After having created the 1x2x3 block in dL, you can \"}<_components.strong>{\"extend it to a 2x2x3\"}</_components.strong>{\" by solving the edges at DF and DB. This can be achieved in two main ways: You can either solve each of them seperately by placing them in the U-layer an then inserting them by doing \"}<_components.code>{\"r U' r'\"}</_components.code>{\", \"}<_components.code>{\"r U2 r'\"}</_components.code>{\", \"}<_components.code>{\"r' U r\"}</_components.code>{\", or \"}<_components.code>{\"r' U2 r\"}</_components.code>{\" depending on the situation. The other option is creating a line consisting of the two edges and the white center in the U-layer and then inserting it by doing an \"}<_components.code>{\"r2\"}</_components.code>{\"-move. This method often is more efficient, especially when the edges are oriented (e.g. have their white side on the U-face, front-right, back-right or D-face).\"}</_components.p>{\"\\n\"}<_components.h4 id={toc[7].id}>{toc[7].value}</_components.h4>{\"\\n\"}<twisty-player id=\"dfdb1-viewer\" experimentalStickeringMaskOrbits=\"EDGES:-I-DIIIIIDID,CORNERS:IIDDIIII,CENTERS:-D----\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"U r U' r' U r' U r\" hint-facelets=\"none\" camera-latitude=\"35\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<twisty-alg-viewer for=\"dfdb1-viewer\" />{\"\\n\"}<twisty-player id=\"dfdb2-viewer\" experimentalStickeringMaskOrbits=\"EDGES:-I-DIIIIIDID,CORNERS:IIDDIIII,CENTERS:-D----\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"R' U' R M' U r2\" hint-facelets=\"none\" camera-latitude=\"35\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<twisty-alg-viewer for=\"dfdb2-viewer\" />{\"\\n\"}<Callout type=\"default\"><_components.p>{\"Instead of creating the 1x2x3 in dL and then solving the DF and DB edges, you can also create the 1x2x3 in Dl and then solve the FL and BL edges.\"}</_components.p></Callout>{\"\\n\"}<_components.h2 id={toc[8].id}>{toc[8].value}</_components.h2>{\"\\n\"}<Image src=\"/images/tutorial/222-223.svg\" width={200} height={200} alt=\"Image of the 2x2x3 being solved using the 2x2x2 to 2x2x3 method\" />{\"\\n\"}<_components.p>{\"An alternative way to solve the 2x2x3 is first creating a 2x2x2 in \"}<_components.em>{\"dbl\"}</_components.em>{\" or \"}<_components.em>{\"dlf\"}</_components.em>{\" and then extending it by attaching a second 1x1x2 block in \"}<_components.em>{\"dlF\"}</_components.em>{\" or \"}<_components.em>{\"dBl\"}</_components.em>{\". This is a very versatile technique too, but it sometimes leads to awkward fingertricks with \"}<_components.code>{\"F2\"}</_components.code>{\"- or \"}<_components.code>{\"B2\"}</_components.code>{\"-moves.\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[9].id}>{toc[9].value}</_components.h3>{\"\\n\"}<Image src=\"/images/tutorial/222-slab.svg\" width={120} height={120} alt=\"Image of the 2x2x2 being solved using the 'slab'-technique\" />{\"\\n\"}<_components.p>{\"One way of creating a 2x2x2 block is by creating a 1x2x2 block in \"}<_components.em>{\"Dbl\"}</_components.em>{\" or \"}<_components.em>{\"Dlf\"}</_components.em>{\". You can then add an edge with the correct two center pieces, creating a 2x2x2. Of course it is also possible to first create a block in \"}<_components.em>{\"Ebl\"}</_components.em>{\" or \"}<_components.em>{\"Elf\"}</_components.em>{\" and then adding the other block. As there is a lot of freedom, we recommend you experiment a bit on your own.\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[10].id}>{toc[10].value}</_components.h3>{\"\\n\"}<Image src=\"/images/tutorial/222-223.svg\" width={120} height={120} alt=\"Image of the 2x2x2 being extended to a 2x2x3\" />{\"\\n\"}<_components.p>{\"To then add another 1x2x2, you can again make use of multiple strategies. Often, you would connect one of the two edges to the center and then attach a corner-edge pair using a sequence like \"}<_components.code>{\"R' F R\"}</_components.code>{\" or \"}<_components.code>{\"L F' L'\"}</_components.code>{\". You might even solve the two edges first and then solve the corner using a keyhole-style insert like \"}<_components.code>{\"D R U R' D'\"}</_components.code>{\".\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[11].id}>{toc[11].value}</_components.h2>{\"\\n\"}<Image src=\"/images/tutorial/cross_2f2l.svg\" width={200} height={200} alt=\"Image of the 2x2x3 being solved using a cross+F2L style method\" />{\"\\n\"}<Callout type=\"error\"><_components.p>{\"Even though you might be tempted to always solve your 2x2x3 like this, this is \"}<_components.strong>{\"NOT\"}</_components.strong>{\" the most efficient method and is only useful on very specific scrambles.\"}</_components.p></Callout>{\"\\n\"}<_components.p>{\"On some scrambles, solving the 2x2x3 like F2L in CFOP, except without any of the pieces in the R-layer, is the fastest method. Even though the movecount might not be too low, this method does allow for high TPS. Keep in mind this is really only recommended if:\"}</_components.p>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.strong>{\"at least two cross pieces are solved or solvable in one move\"}</_components.strong>{\" and\"}</_components.li>{\"\\n\"}<_components.li><_components.strong>{\"at least one of the two edges belonging into FL and BL is oriented\"}</_components.strong>{\" (e.g. has its front/back color on the U-face, D-face if it is in those layers or the front/back face if it is in the E-layer).\"}</_components.li>{\"\\n\"}</_components.ul></>;\n}\nexport default _createMdxContent;\nfunction _missingMdxReference(id, component, place) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\" + (place ? \"\\nIt’s referenced in your code at `\" + place + \"` in `/mnt/datadrive/apbmethod.net/content/tutorial/223.mdx`\" : \"\"));\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2402, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/tutorial/_meta.js"],"sourcesContent":["export default {\n  '223': 'Step 1: 2x2x3',\n  pair: 'Step 2: BR Pair',\n  eo: 'Step 3: Edge Orientation',\n  lxs: 'Step 4: Last Extended Slot (LXS)',\n  ll: 'Step 5: Last Layer'\n}"],"names":[],"mappings":";;;;uCAAe;IACb,OAAO;IACP,MAAM;IACN,IAAI;IACJ,KAAK;IACL,IAAI;AACN","debugId":null}},
    {"offset": {"line": 2417, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/tutorial/eo.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"3. Orienting the Remaining Edges\",\n  \"filePath\": \"content/tutorial/eo.mdx\",\n  \"timestamp\": 1758384366658\n};\nimport {Callout} from 'nextra/components';\nimport Image from 'next/image';\nexport const sourceCode = \"import { Callout } from 'nextra/components'\\nimport Image from 'next/image'\\n\\n<Image src=\\\"/images/tutorial/eo.svg\\\" width={200} height={200} alt=\\\"Image of a cube with the edges oriented\\\"/>\\n# 3. Orienting the Remaining Edges\\nEdge orientation is the third step of APB. In this step, you orient all the unsolved edges to reduce the number of following LXS cases and allow for advanced last layer techniques like ZBLL.\\n\\n## What is Edge Orientation?\\n<Image src=\\\"/images/tutorial/eo-orbits.svg\\\" width={175} height={175} alt=\\\"Image of a cube with the edges oriented\\\"/>\\nEdge orientation is the way an edge is twisted on the cube. **Orienting an edge makes it solvable using only R- and U-moves**. At the same time, this means that the orientation of an edge can not be changed using only R- and U-moves. In the image above, a purple sticker can be moved to the spot of any other purple sticker with only R- and U-moves, but a light gray sticker can never move to a purple sticker and vice versa.\\n\\n## Recognizing Edge Orientation\\nThe orientation of the edges with a white or yellow sticker (so all except the FR edge) can be easily recognized:\\n- 👍 If the white/yellow sticker is in any of the purple spots (or at DR), the edge is **good** (oriented).\\n- 👎 If the white/yellow sticker is in a gray spot (or at RD), the edge is **bad** (misoriented).\\n\\nThe orientation of the FR edge can be recognized by checking where the front sticker is.\\n- 👍 If the front sticker is in any of the purple spots (or at DR), the edge is **good** (oriented).\\n- 👎 If the front sticker is in a gray spot (or at RD), the edge is **bad** (misoriented).\\n\\n## Solving Edge Orientation\\nIn APB, edge orientation is solved algorithmically. There are 11 algorithms, which can be found [here](https://docs.google.com/spreadsheets/d/1Hs9ikHz-4cfbqBfqvuvE8X9sjCb4Jtm482ZvsFQA2rY/) (Note that you only need to learn the algs in the \\\"dBR Solved EO\\\" tab. The other algorithms belong to an older style of solving the BR pair and EO at the same time called [EOPair](/variations/eopair)). In the sheet, bad edges are colored light gray.\\n\\n### Some Example Cases\\n<twisty-player\\n    experimentalStickeringMaskOrbits=\\\"EDGES:------------,CORNERS:-I--IIII\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2 R U R2 U' R U R\\\"\\n    alg=\\\"S' U' S\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"45\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/>\\n<twisty-player\\n    experimentalStickeringMaskOrbits=\\\"EDGES:------------,CORNERS:-I--IIII\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2 R U R2 U' R U R\\\"\\n    alg=\\\"F R' F' R U S' U' S\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"45\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/> \\n<twisty-player\\n    experimentalStickeringMaskOrbits=\\\"EDGES:------------,CORNERS:-I--IIII\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2 R U R2 U' R U R\\\"\\n    alg=\\\"S R' U' R U R S'\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"45\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/> \\n\\n## Fingertricking S-Moves\\n<Callout type=\\\"info\\\">\\n    S-moves go in the same direction as F-moves.\\n</Callout>\\nYou might not be used to doing S-moves in the middle of your solve, but they are really not a problem if you practise them. Try to think of them as just F-moves but one layer further back. Unlike F-moves however, you should be able to do push-turns as well. If you still have problems, see the small guide below:\\n- **S-moves:** Either use your right index finger to **pull on the UR edge** from the top (do make sure that you **don't** use the very tip of the finger) or use your left index finger and **push on the UL edge** from the left.\\n- **S'-moves:** Either use your left index finger to **pull on the UL edge** from the top (do make sure that you **don't** use the very tip of the finger) or use your right index finger and **push on the UR edge** from the right.\";\nfunction useTOC(props) {\n  return [{\n    value: \"What is Edge Orientation?\",\n    id: \"what-is-edge-orientation\",\n    depth: 2\n  }, {\n    value: \"Recognizing Edge Orientation\",\n    id: \"recognizing-edge-orientation\",\n    depth: 2\n  }, {\n    value: \"Solving Edge Orientation\",\n    id: \"solving-edge-orientation\",\n    depth: 2\n  }, {\n    value: \"Some Example Cases\",\n    id: \"some-example-cases\",\n    depth: 3\n  }, {\n    value: \"Fingertricking S-Moves\",\n    id: \"fingertricking-s-moves\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/tutorial/eo.svg\" width={200} height={200} alt=\"Image of a cube with the edges oriented\" />{\"\\n\"}<_components.h1>{\"3. Orienting the Remaining Edges\"}</_components.h1>{\"\\n\"}<_components.p>{\"Edge orientation is the third step of APB. In this step, you orient all the unsolved edges to reduce the number of following LXS cases and allow for advanced last layer techniques like ZBLL.\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<Image src=\"/images/tutorial/eo-orbits.svg\" width={175} height={175} alt=\"Image of a cube with the edges oriented\" />{\"\\n\"}<_components.p>{\"Edge orientation is the way an edge is twisted on the cube. \"}<_components.strong>{\"Orienting an edge makes it solvable using only R- and U-moves\"}</_components.strong>{\". At the same time, this means that the orientation of an edge can not be changed using only R- and U-moves. In the image above, a purple sticker can be moved to the spot of any other purple sticker with only R- and U-moves, but a light gray sticker can never move to a purple sticker and vice versa.\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[1].id}>{toc[1].value}</_components.h2>{\"\\n\"}<_components.p>{\"The orientation of the edges with a white or yellow sticker (so all except the FR edge) can be easily recognized:\"}</_components.p>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li>{\"👍 If the white/yellow sticker is in any of the purple spots (or at DR), the edge is \"}<_components.strong>{\"good\"}</_components.strong>{\" (oriented).\"}</_components.li>{\"\\n\"}<_components.li>{\"👎 If the white/yellow sticker is in a gray spot (or at RD), the edge is \"}<_components.strong>{\"bad\"}</_components.strong>{\" (misoriented).\"}</_components.li>{\"\\n\"}</_components.ul>{\"\\n\"}<_components.p>{\"The orientation of the FR edge can be recognized by checking where the front sticker is.\"}</_components.p>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li>{\"👍 If the front sticker is in any of the purple spots (or at DR), the edge is \"}<_components.strong>{\"good\"}</_components.strong>{\" (oriented).\"}</_components.li>{\"\\n\"}<_components.li>{\"👎 If the front sticker is in a gray spot (or at RD), the edge is \"}<_components.strong>{\"bad\"}</_components.strong>{\" (misoriented).\"}</_components.li>{\"\\n\"}</_components.ul>{\"\\n\"}<_components.h2 id={toc[2].id}>{toc[2].value}</_components.h2>{\"\\n\"}<_components.p>{\"In APB, edge orientation is solved algorithmically. There are 11 algorithms, which can be found \"}<_components.a href=\"https://docs.google.com/spreadsheets/d/1Hs9ikHz-4cfbqBfqvuvE8X9sjCb4Jtm482ZvsFQA2rY/\">{\"here\"}</_components.a>{\" (Note that you only need to learn the algs in the “dBR Solved EO” tab. The other algorithms belong to an older style of solving the BR pair and EO at the same time called \"}<_components.a href=\"/variations/eopair\">{\"EOPair\"}</_components.a>{\"). In the sheet, bad edges are colored light gray.\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[3].id}>{toc[3].value}</_components.h3>{\"\\n\"}<twisty-player experimentalStickeringMaskOrbits=\"EDGES:------------,CORNERS:-I--IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2 R U R2 U' R U R\" alg=\"S' U' S\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<twisty-player experimentalStickeringMaskOrbits=\"EDGES:------------,CORNERS:-I--IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2 R U R2 U' R U R\" alg=\"F R' F' R U S' U' S\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<twisty-player experimentalStickeringMaskOrbits=\"EDGES:------------,CORNERS:-I--IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2 R U R2 U' R U R\" alg=\"S R' U' R U R S'\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<_components.h2 id={toc[4].id}>{toc[4].value}</_components.h2>{\"\\n\"}<Callout type=\"info\"><_components.p>{\"S-moves go in the same direction as F-moves.\"}</_components.p></Callout>{\"\\n\"}<_components.p>{\"You might not be used to doing S-moves in the middle of your solve, but they are really not a problem if you practise them. Try to think of them as just F-moves but one layer further back. Unlike F-moves however, you should be able to do push-turns as well. If you still have problems, see the small guide below:\"}</_components.p>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.strong>{\"S-moves:\"}</_components.strong>{\" Either use your right index finger to \"}<_components.strong>{\"pull on the UR edge\"}</_components.strong>{\" from the top (do make sure that you \"}<_components.strong>{\"don’t\"}</_components.strong>{\" use the very tip of the finger) or use your left index finger and \"}<_components.strong>{\"push on the UL edge\"}</_components.strong>{\" from the left.\"}</_components.li>{\"\\n\"}<_components.li><_components.strong>{\"S’-moves:\"}</_components.strong>{\" Either use your left index finger to \"}<_components.strong>{\"pull on the UL edge\"}</_components.strong>{\" from the top (do make sure that you \"}<_components.strong>{\"don’t\"}</_components.strong>{\" use the very tip of the finger) or use your right index finger and \"}<_components.strong>{\"push on the UR edge\"}</_components.strong>{\" from the right.\"}</_components.li>{\"\\n\"}</_components.ul></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"AAAA,uBAAuB,GACvB,wBAAwB;;;;;;;;;;;AACxB;AAMA;AACA;;;AANO,MAAM,WAAW;IACtB,SAAS;IACT,YAAY;IACZ,aAAa;AACf;;;AAGO,MAAM,aAAa;AAC1B,SAAS,OAAO,KAAK;IACnB,OAAO;QAAC;YACN,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;KAAE;AACJ;AACO,MAAM,MAAM,OAAO,CAAC;AAC3B,SAAS,kBAAkB,KAAK;IAC9B,MAAM,cAAc;QAClB,GAAG;QACH,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,GAAG;QACH,QAAQ;QACR,IAAI;QACJ,GAAG,IAAA,qIAAkB,GAAE;QACvB,GAAG,MAAM,UAAU;IACrB;IACA,qBAAO;;0BAAE,8OAAC,wIAAK;gBAAC,KAAI;gBAA0B,OAAO;gBAAK,QAAQ;gBAAK,KAAI;;;;;;YAA6C;0BAAK,8OAAC,YAAY,EAAE;0BAAE;;;;;;YAAqD;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAAkN;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,wIAAK;gBAAC,KAAI;gBAAiC,OAAO;gBAAK,QAAQ;gBAAK,KAAI;;;;;;YAA6C;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAA+D,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAAsF;;;;;;;YAAgU;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAAqI;0BAAK,8OAAC,YAAY,EAAE;;oBAAE;kCAAK,8OAAC,YAAY,EAAE;;4BAAE;0CAAwF,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA6B;;;;;;;oBAAiC;kCAAK,8OAAC,YAAY,EAAE;;4BAAE;0CAA4E,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA4B;;;;;;;oBAAoC;;;;;;;YAAuB;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAA4G;0BAAK,8OAAC,YAAY,EAAE;;oBAAE;kCAAK,8OAAC,YAAY,EAAE;;4BAAE;0CAAiF,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA6B;;;;;;;oBAAiC;kCAAK,8OAAC,YAAY,EAAE;;4BAAE;0CAAqE,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA4B;;;;;;;oBAAoC;;;;;;;YAAuB;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAmG,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAwF;;;;;;oBAAwB;kCAA+K,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAsB;;;;;;oBAA0B;;;;;;;YAAsE;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC;gBAAc,kCAAiC;gBAAsC,6BAA0B;gBAAM,0BAAuB;gBAAqB,KAAI;gBAAU,iBAAc;gBAAO,mBAAgB;gBAAK,oBAAiB;gBAAK,gBAAa;;;;;;YAAU;0BAAK,8OAAC;gBAAc,kCAAiC;gBAAsC,6BAA0B;gBAAM,0BAAuB;gBAAqB,KAAI;gBAAsB,iBAAc;gBAAO,mBAAgB;gBAAK,oBAAiB;gBAAK,gBAAa;;;;;;YAAU;0BAAK,8OAAC;gBAAc,kCAAiC;gBAAsC,6BAA0B;gBAAM,0BAAuB;gBAAqB,KAAI;gBAAmB,iBAAc;gBAAO,mBAAgB;gBAAK,oBAAiB;gBAAK,gBAAa;;;;;;YAAU;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,4KAAO;gBAAC,MAAK;0BAAO,cAAA,8OAAC,YAAY,CAAC;8BAAE;;;;;;;;;;;YAA0E;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAA4U;0BAAK,8OAAC,YAAY,EAAE;;oBAAE;kCAAK,8OAAC,YAAY,EAAE;;0CAAC,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAAiC;0CAA0C,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA4C;0CAAwC,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA8B;0CAAsE,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA4C;;;;;;;oBAAoC;kCAAK,8OAAC,YAAY,EAAE;;0CAAC,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAAkC;0CAAyC,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA4C;0CAAwC,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA8B;0CAAuE,8OAAC,YAAY,MAAM;0CAAE;;;;;;4BAA4C;;;;;;;oBAAqC;;;;;;;;;AACpqK;uCACe","debugId":null}},
    {"offset": {"line": 2890, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/tutorial/ll.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"3. Solving the Last Layer\",\n  \"filePath\": \"content/tutorial/ll.mdx\",\n  \"timestamp\": 1758384360735\n};\nimport {Callout, Steps} from 'nextra/components';\nimport Image from 'next/image';\nexport const sourceCode = \"import { Steps } from 'nextra/components'\\nimport Image from 'next/image'\\n\\n<Image src=\\\"/images/apb_icon.svg\\\" width={250} height={250} alt=\\\"APB Icon\\\"/>\\n# Welcome to the APB Method Website\\nWelcome to **apbmethod.net**! This site is a learning resource for all levels of APB solvers. If you are looking for a tutorial on the method, see [here](/tutorial).\\n\\n## The APB Method\\nAPB is a **3x3 speedsolving method** proposed by **James Straughan aka. Athefre** in 2021. You can check out his overview [here](https://sites.google.com/view/apb-system/overview). Having a movecount of about 48-50 moves and being very algorithm-based, it has **a lot of potential** for being fast at a high level.\\n\\nStandard APB consists of 5 steps:\\n<Steps>\\n    {<h3>2x2x3 block on the left side</h3>}\\n    Solve a 2x2x3 block in the bottom-left. This is usually accomplished by building a Roux-style 1x2x3 block and then extending it by solving the DF and DB edges.\\n\\n    {<h3>Solving the back-right F2L-pair</h3>}\\n    The back-right F2L pair is solved intuitively.\\n\\n    {<h3>Solve the edge-orientation of the remaining edges (EO)</h3>}\\n    The edge-orientation of the remaining edges is solved algorithmically (11 algorithms).\\n\\n    {<h3>Solve the last three F2L pieces (LXS)</h3>}\\n    The remaining three F2L pieces are solved algorithmically (116 algorithms).\\n\\n    {<h3>Solve the last layer</h3>}\\n    The last layer is solved using either OCLL + PLL or ZBLL, which consists of 493 algorithms.\\n</Steps>\\n\\n## About Me\\nHi, this is [JustEnoughAlgorithms](https://www.youtube.com/@justenoughalgorithms) and I'm the creator of this website. I've been using APB since autumn of 2023 and have been using it in competition ever since. I've managed to beat all of my old PBs that I had set with Roux. [My WCA Profile](https://www.worldcubeassociation.org/persons/2022PERR01)\\n\\n## About this site\\nThis website was very much inspired by [zzmethod.com](https://zzmethod.com) made by [crystalcuber](https://www.youtube.com/@crystalcuber). It was created using [nextra](https://nextra.site).\\n\\n## Contribute\\nIf you have an idea or want to contribute, create an issue on this book's [GitHub Page](https://github.com/phalentin/apbmethod.net) or create a pull request.\";\nfunction useTOC(props) {\n  return [{\n    value: \"OCLL + PLL\",\n    id: \"ocll--pll\",\n    depth: 2\n  }, {\n    value: \"1. OCLL\",\n    id: \"1-ocll\",\n    depth: 3\n  }, {\n    value: \"2. PLL\",\n    id: \"2-pll\",\n    depth: 3\n  }, {\n    value: \"ZBLL\",\n    id: \"zbll\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/tutorial/ll.svg\" width={200} height={200} alt=\"Image of a cube with the last layer solved\" />{\"\\n\"}<_components.h1>{\"3. Solving the Last Layer\"}</_components.h1>{\"\\n\"}<_components.p>{\"The final step of APB is the last layer. Solvers can use two main strategies here:\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<_components.p>{\"First solving \"}<_components.strong>{\"OCLL and then PLL\"}</_components.strong>{\" is definitely the easiest option. It requires 28 algorithms, although most CFOP solvers will already have learned these.\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[1].id}>{toc[1].value}</_components.h3>{\"\\n\"}<_components.p>{\"OCLL are the OLL algorithms where the cross is already solved. They solve the orientation of the U-layer corners. They can be found \"}<_components.a href=\"https://speedcubedb.com/a/3x3/OLL\">{\"here\"}</_components.a>{\" (Make sure you select \"}<_components.em>{\"OCLL\"}</_components.em>{\" at the top).\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[2].id}>{toc[2].value}</_components.h3>{\"\\n\"}<_components.p>{\"PLL permutes the last layer pieces. The algorithms can be found \"}<_components.a href=\"https://speedcubedb.com/a/3x3/PLL\">{\"here\"}</_components.a>{\".\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[3].id}>{toc[3].value}</_components.h2>{\"\\n\"}<_components.p>{\"At a higher level, \"}<_components.strong>{\"ZBLL\"}</_components.strong>{\" can be used to solve the last layer in one step. Further information on ZBLL can be found \"}<_components.a href=\"/advanced/zbll\">{\"here\"}</_components.a>{\".\"}</_components.p></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"AAAA,uBAAuB,GACvB,wBAAwB;;;;;;;;;;;AACxB;AAOA;;;AANO,MAAM,WAAW;IACtB,SAAS;IACT,YAAY;IACZ,aAAa;AACf;;AAGO,MAAM,aAAa;AAC1B,SAAS,OAAO,KAAK;IACnB,OAAO;QAAC;YACN,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;KAAE;AACJ;AACO,MAAM,MAAM,OAAO,CAAC;AAC3B,SAAS,kBAAkB,KAAK;IAC9B,MAAM,cAAc;QAClB,GAAG;QACH,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,GAAG;QACH,QAAQ;QACR,GAAG,IAAA,qIAAkB,GAAE;QACvB,GAAG,MAAM,UAAU;IACrB;IACA,qBAAO;;0BAAE,8OAAC,wIAAK;gBAAC,KAAI;gBAA0B,OAAO;gBAAK,QAAQ;gBAAK,KAAI;;;;;;YAAgD;0BAAK,8OAAC,YAAY,EAAE;0BAAE;;;;;;YAA8C;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAAsG;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAiB,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAA0C;;;;;;;YAA6I;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAuI,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAqC;;;;;;oBAAwB;kCAA0B,8OAAC,YAAY,EAAE;kCAAE;;;;;;oBAAyB;;;;;;;YAAiC;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAmE,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAqC;;;;;;oBAAwB;;;;;;;YAAqB;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAsB,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAA6B;kCAA8F,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAkB;;;;;;oBAAwB;;;;;;;;;AACvkD;uCACe","debugId":null}},
    {"offset": {"line": 3112, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/tutorial/lxs.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"4. Solving the Last Extended Slot (LXS)\",\n  \"filePath\": \"content/tutorial/lxs.mdx\",\n  \"timestamp\": 1758384360735\n};\nimport {Callout, Steps} from 'nextra/components';\nimport Image from 'next/image';\nexport const sourceCode = \"import { Steps } from 'nextra/components'\\nimport Image from 'next/image'\\n\\n<Image src=\\\"/images/apb_icon.svg\\\" width={250} height={250} alt=\\\"APB Icon\\\"/>\\n# Welcome to the APB Method Website\\nWelcome to **apbmethod.net**! This site is a learning resource for all levels of APB solvers. If you are looking for a tutorial on the method, see [here](/tutorial).\\n\\n## The APB Method\\nAPB is a **3x3 speedsolving method** proposed by **James Straughan aka. Athefre** in 2021. You can check out his overview [here](https://sites.google.com/view/apb-system/overview). Having a movecount of about 48-50 moves and being very algorithm-based, it has **a lot of potential** for being fast at a high level.\\n\\nStandard APB consists of 5 steps:\\n<Steps>\\n    {<h3>2x2x3 block on the left side</h3>}\\n    Solve a 2x2x3 block in the bottom-left. This is usually accomplished by building a Roux-style 1x2x3 block and then extending it by solving the DF and DB edges.\\n\\n    {<h3>Solving the back-right F2L-pair</h3>}\\n    The back-right F2L pair is solved intuitively.\\n\\n    {<h3>Solve the edge-orientation of the remaining edges (EO)</h3>}\\n    The edge-orientation of the remaining edges is solved algorithmically (11 algorithms).\\n\\n    {<h3>Solve the last three F2L pieces (LXS)</h3>}\\n    The remaining three F2L pieces are solved algorithmically (116 algorithms).\\n\\n    {<h3>Solve the last layer</h3>}\\n    The last layer is solved using either OCLL + PLL or ZBLL, which consists of 493 algorithms.\\n</Steps>\\n\\n## About Me\\nHi, this is [JustEnoughAlgorithms](https://www.youtube.com/@justenoughalgorithms) and I'm the creator of this website. I've been using APB since autumn of 2023 and have been using it in competition ever since. I've managed to beat all of my old PBs that I had set with Roux. [My WCA Profile](https://www.worldcubeassociation.org/persons/2022PERR01)\\n\\n## About this site\\nThis website was very much inspired by [zzmethod.com](https://zzmethod.com) made by [crystalcuber](https://www.youtube.com/@crystalcuber). It was created using [nextra](https://nextra.site).\\n\\n## Contribute\\nIf you have an idea or want to contribute, create an issue on this book's [GitHub Page](https://github.com/phalentin/apbmethod.net) or create a pull request.\";\nfunction useTOC(props) {\n  return [{\n    value: \"Algorithms\",\n    id: \"algorithms\",\n    depth: 2\n  }, {\n    value: \"Some Example Cases\",\n    id: \"some-example-cases\",\n    depth: 3\n  }, {\n    value: \"Beginner Approaches\",\n    id: \"beginner-approaches\",\n    depth: 2\n  }, {\n    value: \"Solving the F2L Pair and then the DR Edge\",\n    id: \"solving-the-f2l-pair-and-then-the-dr-edge\",\n    depth: 3\n  }, {\n    value: \"Inserting the Corner and then doing LXS\",\n    id: \"inserting-the-corner-and-then-doing-lxs\",\n    depth: 3\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/tutorial/lxs.svg\" width={200} height={200} alt=\"Image of a cube with LXS solved\" />{\"\\n\"}<_components.h1>{\"4. Solving the Last Extended Slot (LXS)\"}</_components.h1>{\"\\n\"}<_components.p>{\"The last extended slot or LXS is probably the best step of the APB method. In this step, the solvers \"}<_components.strong>{\"solves the three remaining pieces in the d-layer\"}</_components.strong>{\". This is done algorithmically and consists of \"}<_components.strong>{\"116 cases\"}</_components.strong>{\".\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<_components.p>{\"The LXS-algorithms can be found \"}<_components.a href=\"https://docs.google.com/spreadsheets/d/1P2DB0SyA1BrezYJ_g7RJ7_l32Ilxq7lLtr53zlG_TUU/\">{\"here\"}</_components.a>{\". Liam Highducheck has created a sheet which categorizes all the cases into seven categories for easier learning. It can be found \"}<_components.a href=\"https://docs.google.com/spreadsheets/d/1ACKQXpMK0b8RWGoN9wMDbnF-W-S4mMdeJH5IcjeEyf8/\">{\"here\"}</_components.a>{\".\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[1].id}>{toc[1].value}</_components.h3>{\"\\n\"}<twisty-player experimentalStickeringMaskOrbits=\"EDGES:----IIII----,CORNERS:----IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"R U2' R' U2 R' U2' R2 U2' R\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<twisty-player experimentalStickeringMaskOrbits=\"EDGES:----IIII----,CORNERS:----IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"R' U' R' U' R U2 R\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<twisty-player experimentalStickeringMaskOrbits=\"EDGES:----IIII----,CORNERS:----IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"R U R' U' R U' R' U R' U' R U R\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<Callout type=\"default\"><_components.p>{\"At a higher level, solvers can also learn dBL LXS and EO, which enables them to solve the FR pair and then do EO and LXS for the back slot. Usually, this is not worth it though.\"}</_components.p></Callout>{\"\\n\"}<_components.h2 id={toc[2].id}>{toc[2].value}</_components.h2>{\"\\n\"}<_components.p>{\"There are two main beginner approaches to solve LXS without or with fewer algorithms:\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[3].id}>{toc[3].value}</_components.h3>{\"\\n\"}<_components.p>{\"If you haven’t learned any of the algorithms yet, you can follow the following approach:\"}</_components.p>{\"\\n\"}<Steps>{<h3>Solve the dFR Pair</h3>}<_components.p><_components.strong>{\"Solve the dFR pair like an F2L pair\"}</_components.strong>{\" while ignoring the edge belonging into DR. If the F2L edge is at DR, you have to take it out using \"}<_components.code>{\"S R2' S' R2\"}</_components.code>{\".\"}</_components.p>{<h3>Solve the DR Edge</h3>}<_components.p><_components.strong>{\"Solve the DR edge\"}</_components.strong>{\" by putting it at UL and then doing \"}<_components.code>{\"S R2' S' R2\"}</_components.code>{\".\"}</_components.p></Steps>{\"\\n\"}<_components.p>{\"Below is an example solution using this approach:\"}</_components.p>{\"\\n\"}<twisty-player id=\"lxs-beginner1\" experimentalStickeringMaskOrbits=\"EDGES:----IIII----,CORNERS:----IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"\nS R2' S' R2 R U2' R' U R U' R' U2 S R2' S' R2\n\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<_components.h3 id={toc[4].id}>{toc[4].value}</_components.h3>{\"\\n\"}<_components.p>{\"If you have learned all the LXS cases with the corner in the D-layer, this approach allows you to do LXS in two steps:\"}</_components.p>{\"\\n\"}<Steps>{<h3>Insert the Corner into DFR</h3>}<_components.p><_components.strong>{\"Insert the corner\"}</_components.strong>{\" belonging into DFR. If you know all the LXS cases with the corner in the D-layer, the orientation doesn’t matter. If you haven’t learned all three sets, \"}<_components.strong>{\"the orientation has to match up\"}</_components.strong>{\" with one of the sets you learned.\"}</_components.p>{<h3>Solve the LXS case</h3>}<_components.p>{\"Do the alg for the LXS case you have now.\"}</_components.p></Steps>{\"\\n\"}<_components.p>{\"Below is an example solution using this approach:\"}</_components.p>{\"\\n\"}<twisty-player id=\"lxs-beginner1\" experimentalStickeringMaskOrbits=\"EDGES:----IIII----,CORNERS:----IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"\nU' R U R' U2 R U' R' U R' U2' R U2 R\n\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" /></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3563, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/tutorial/pair.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"2. Solving the BR Pair\",\n  \"filePath\": \"content/tutorial/pair.mdx\",\n  \"timestamp\": 1758384363254\n};\nimport Image from 'next/image';\nexport const sourceCode = \"import Image from 'next/image'\\n\\n<Image src=\\\"/images/tutorial/pair.svg\\\" width={200} height={200} alt=\\\"Image of a cube with the BR pair solved\\\"/>\\n# 2. Solving the BR Pair\\n**Solving the dBR pair** is the second step of APB. This is probably the most trivial step, as it can be completed **intuitively** and CFOP-solvers will already be familiar with it.\\n\\n## Oriented BR Edge\\nIf the BR edge is oriented (e.g. its back color is on top, bottom or at the front right), the standard CFOP solution will be the fastest most of the time. It is, however, often possible not to undo R-moves (see example).\\n<twisty-player\\n    experimentalStickeringMaskOrbits=\\\"EDGES:-I--IIII--I-,CORNERS:-I--IIII\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2\\\"\\n    alg=\\\"R U' R\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"45\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/>\\n\\n## Misoriented BR Edge\\nWhen the BR edge is misoriented (e.g. its right color is on top, bottom, at the front right or back right), there are often **fast solutions using S-moves** (see example). If there is no fancy S-move solution, you can connect the two pieces and then insert them by doing `f R' f'`.\\n<twisty-player\\n    experimentalStickeringMaskOrbits=\\\"EDGES:-I--IIII--I-,CORNERS:-I--IIII\\\"\\n    experimental-setup-anchor=\\\"end\\\"\\n    experimental-setup-alg=\\\"x2\\\"\\n    alg=\\\"S R' S'\\\"\\n    hint-facelets=\\\"none\\\"\\n    camera-latitude=\\\"45\\\"\\n    camera-longitude=\\\"25\\\"\\n    color-scheme=\\\"dark\\\"\\n/>\\n\\n## Algorithm Sheet\\n**For some cases**, especially those with a misoriented edge, **learning the most efficient solution is really helpful**. Those solutions can be found in [Liam Highducheck's sheet](https://docs.google.com/spreadsheets/d/1U1nwq_-HLeDgajuAOVRaH2Jo7X9zSTEBrnIRSv3hzeg/edit?gid=983211243#gid=983211243).\";\nfunction useTOC(props) {\n  return [{\n    value: \"Oriented BR Edge\",\n    id: \"oriented-br-edge\",\n    depth: 2\n  }, {\n    value: \"Misoriented BR Edge\",\n    id: \"misoriented-br-edge\",\n    depth: 2\n  }, {\n    value: \"Algorithm Sheet\",\n    id: \"algorithm-sheet\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/tutorial/pair.svg\" width={200} height={200} alt=\"Image of a cube with the BR pair solved\" />{\"\\n\"}<_components.h1>{\"2. Solving the BR Pair\"}</_components.h1>{\"\\n\"}<_components.p><_components.strong>{\"Solving the dBR pair\"}</_components.strong>{\" is the second step of APB. This is probably the most trivial step, as it can be completed \"}<_components.strong>{\"intuitively\"}</_components.strong>{\" and CFOP-solvers will already be familiar with it.\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<_components.p>{\"If the BR edge is oriented (e.g. its back color is on top, bottom or at the front right), the standard CFOP solution will be the fastest most of the time. It is, however, often possible not to undo R-moves (see example).\"}</_components.p>{\"\\n\"}<twisty-player experimentalStickeringMaskOrbits=\"EDGES:-I--IIII--I-,CORNERS:-I--IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"R U' R\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<_components.h2 id={toc[1].id}>{toc[1].value}</_components.h2>{\"\\n\"}<_components.p>{\"When the BR edge is misoriented (e.g. its right color is on top, bottom, at the front right or back right), there are often \"}<_components.strong>{\"fast solutions using S-moves\"}</_components.strong>{\" (see example). If there is no fancy S-move solution, you can connect the two pieces and then insert them by doing \"}<_components.code>{\"f R' f'\"}</_components.code>{\".\"}</_components.p>{\"\\n\"}<twisty-player experimentalStickeringMaskOrbits=\"EDGES:-I--IIII--I-,CORNERS:-I--IIII\" experimental-setup-anchor=\"end\" experimental-setup-alg=\"x2\" alg=\"S R' S'\" hint-facelets=\"none\" camera-latitude=\"45\" camera-longitude=\"25\" color-scheme=\"dark\" />{\"\\n\"}<_components.h2 id={toc[2].id}>{toc[2].value}</_components.h2>{\"\\n\"}<_components.p><_components.strong>{\"For some cases\"}</_components.strong>{\", especially those with a misoriented edge, \"}<_components.strong>{\"learning the most efficient solution is really helpful\"}</_components.strong>{\". Those solutions can be found in \"}<_components.a href=\"https://docs.google.com/spreadsheets/d/1U1nwq_-HLeDgajuAOVRaH2Jo7X9zSTEBrnIRSv3hzeg/edit?gid=983211243#gid=983211243\">{\"Liam Highducheck’s sheet\"}</_components.a>{\".\"}</_components.p></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"AAAA,uBAAuB,GACvB,wBAAwB;;;;;;;;;;;AACxB;AAMA;;;AALO,MAAM,WAAW;IACtB,SAAS;IACT,YAAY;IACZ,aAAa;AACf;;AAEO,MAAM,aAAa;AAC1B,SAAS,OAAO,KAAK;IACnB,OAAO;QAAC;YACN,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;QAAG;YACD,OAAO;YACP,IAAI;YACJ,OAAO;QACT;KAAE;AACJ;AACO,MAAM,MAAM,OAAO,CAAC;AAC3B,SAAS,kBAAkB,KAAK;IAC9B,MAAM,cAAc;QAClB,GAAG;QACH,MAAM;QACN,IAAI;QACJ,IAAI;QACJ,GAAG;QACH,QAAQ;QACR,GAAG,IAAA,qIAAkB,GAAE;QACvB,GAAG,MAAM,UAAU;IACrB;IACA,qBAAO;;0BAAE,8OAAC,wIAAK;gBAAC,KAAI;gBAA4B,OAAO;gBAAK,QAAQ;gBAAK,KAAI;;;;;;YAA6C;0BAAK,8OAAC,YAAY,EAAE;0BAAE;;;;;;YAA2C;0BAAK,8OAAC,YAAY,CAAC;;kCAAC,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAA6C;kCAA8F,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAAoC;;;;;;;YAAuE;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAAgP;0BAAK,8OAAC;gBAAc,kCAAiC;gBAAsC,6BAA0B;gBAAM,0BAAuB;gBAAK,KAAI;gBAAS,iBAAc;gBAAO,mBAAgB;gBAAK,oBAAiB;gBAAK,gBAAa;;;;;;YAAU;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAA+H,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAAqD;kCAAsH,8OAAC,YAAY,IAAI;kCAAE;;;;;;oBAA8B;;;;;;;YAAqB;0BAAK,8OAAC;gBAAc,kCAAiC;gBAAsC,6BAA0B;gBAAM,0BAAuB;gBAAK,KAAI;gBAAU,iBAAc;gBAAO,mBAAgB;gBAAK,oBAAiB;gBAAK,gBAAa;;;;;;YAAU;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,CAAC;;kCAAC,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAAuC;kCAA+C,8OAAC,YAAY,MAAM;kCAAE;;;;;;oBAA+E;kCAAqC,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAAwH;;;;;;oBAA4C;;;;;;;;;AACnxE;uCACe","debugId":null}},
    {"offset": {"line": 3794, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/variations/_meta.js"],"sourcesContent":["export default {\n  eopair: 'EOPair',\n  'back-lxs-eo': 'Back Slot LXS & EO'\n}"],"names":[],"mappings":";;;;uCAAe;IACb,QAAQ;IACR,eAAe;AACjB","debugId":null}},
    {"offset": {"line": 3806, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/variations/back-lxs-eo.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"Back Slot LXS & Edge Orientation\",\n  \"filePath\": \"content/variations/back-lxs-eo.mdx\",\n  \"timestamp\": 1758384362357\n};\nimport Image from 'next/image';\nexport const sourceCode = \"import Image from 'next/image'\\n\\n<Image src=\\\"/images/variations/back-lxs-eo.svg\\\" width={200} height={200} alt=\\\"Image of a cube with the last layer solved\\\" lnk=\\\"?fmt=svg&r=y35x-25&bg=t&&fc=dlglygdlddrrrrrrlddldbbbbbb\\\"/>\\n# Back Slot LXS & Edge Orientation\\nInstead of solving the BR pair and then doing LXS and EO on the dfR pieces, you can solve the FR pair and then do LXS and EO on the dbR pieces. This has the obvious disatvantages of having to learn 127 new EO and LXS algorithms and more blind spots. It can still be worth it on some scrambles that have a very easy or solved FR pair after completing the 2x2x3. \\n\\n## Algorithms\\n- [Back Slot LXS](https://docs.google.com/spreadsheets/d/1Xa6251D9G00g-jMQy0KzUg7xx39rsSjkJLMzsxinC7Q/)\\n- [Back Slot EO](https://docs.google.com/spreadsheets/d/1Hs9ikHz-4cfbqBfqvuvE8X9sjCb4Jtm482ZvsFQA2rY/edit?gid=321284838)\";\nfunction useTOC(props) {\n  return [{\n    value: \"Algorithms\",\n    id: \"algorithms\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    h2: \"h2\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/variations/back-lxs-eo.svg\" width={200} height={200} alt=\"Image of a cube with the last layer solved\" lnk=\"?fmt=svg&amp;r=y35x-25&amp;bg=t&&amp;fc=dlglygdlddrrrrrrlddldbbbbbb\" />{\"\\n\"}<_components.h1>{\"Back Slot LXS & Edge Orientation\"}</_components.h1>{\"\\n\"}<_components.p>{\"Instead of solving the BR pair and then doing LXS and EO on the dfR pieces, you can solve the FR pair and then do LXS and EO on the dbR pieces. This has the obvious disatvantages of having to learn 127 new EO and LXS algorithms and more blind spots. It can still be worth it on some scrambles that have a very easy or solved FR pair after completing the 2x2x3.\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1Xa6251D9G00g-jMQy0KzUg7xx39rsSjkJLMzsxinC7Q/\">{\"Back Slot LXS\"}</_components.a></_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1Hs9ikHz-4cfbqBfqvuvE8X9sjCb4Jtm482ZvsFQA2rY/edit?gid=321284838\">{\"Back Slot EO\"}</_components.a></_components.li>{\"\\n\"}</_components.ul></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"AAAA,uBAAuB,GACvB,wBAAwB;;;;;;;;;;;AACxB;AAMA;;;AALO,MAAM,WAAW;IACtB,SAAS;IACT,YAAY;IACZ,aAAa;AACf;;AAEO,MAAM,aAAa;AAC1B,SAAS,OAAO,KAAK;IACnB,OAAO;QAAC;YACN,OAAO;YACP,IAAI;YACJ,OAAO;QACT;KAAE;AACJ;AACO,MAAM,MAAM,OAAO,CAAC;AAC3B,SAAS,kBAAkB,KAAK;IAC9B,MAAM,cAAc;QAClB,GAAG;QACH,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,GAAG;QACH,IAAI;QACJ,GAAG,IAAA,qIAAkB,GAAE;QACvB,GAAG,MAAM,UAAU;IACrB;IACA,qBAAO;;0BAAE,8OAAC,wIAAK;gBAAC,KAAI;gBAAqC,OAAO;gBAAK,QAAQ;gBAAK,KAAI;gBAA6C,KAAI;;;;;;YAAyE;0BAAK,8OAAC,YAAY,EAAE;0BAAE;;;;;;YAAqD;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAA4X;0BAAK,8OAAC,YAAY,EAAE;gBAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;0BAAG,GAAG,CAAC,EAAE,CAAC,KAAK;;;;;;YAAmB;0BAAK,8OAAC,YAAY,EAAE;;oBAAE;kCAAK,8OAAC,YAAY,EAAE;kCAAC,cAAA,8OAAC,YAAY,CAAC;4BAAC,MAAK;sCAAwF;;;;;;;;;;;oBAAkD;kCAAK,8OAAC,YAAY,EAAE;kCAAC,cAAA,8OAAC,YAAY,CAAC;4BAAC,MAAK;sCAA0G;;;;;;;;;;;oBAAiD;;;;;;;;;AAC/nC;uCACe","debugId":null}},
    {"offset": {"line": 3935, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/variations/eopair.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"EOPair: Inserting the Pair and Solving EO at the Same Time\",\n  \"filePath\": \"content/variations/eopair.mdx\",\n  \"timestamp\": 1758384364081\n};\nimport Image from 'next/image';\nexport const sourceCode = \"import Image from 'next/image'\\n\\n<Image src=\\\"/images/variations/eopair.svg\\\" width={200} height={200} alt=\\\"Image of a cube with an EOPair case\\\" lnk=\\\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&r=y35x-25&bg=t&fc=dldlyrddrggddrldddddwbbdbbd\\\"/>\\n# EOPair: Inserting the Pair and Solving EO at the Same Time\\nEOPair is an algirithm set for inserting the back-right pair while orienting the edges at the same time. It is divided into four subsets, two with the pair in the U-layer, two with the pair in the R-layer. For both of these positions, there are algorithms for an oriented and a misoriented pair. EOPair used to be part of standard APB. At some point, solvers realized that it only saved about 0.3 moves on average while it consists of 128 algorithms. This trade-off is not worth it in most cases. It is rather recommended to learn the most efficient solutions for all the possible pair cases. If you still want to learn EOPair, it is recommended you start with the misoriented U subset.\\n\\nThe algorithms can be found in the [regular EO algorithm sheet](https://docs.google.com/spreadsheets/d/1Hs9ikHz-4cfbqBfqvuvE8X9sjCb4Jtm482ZvsFQA2rY/edit?gid=1684874333).\";\nfunction useTOC(props) {\n  return [];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/variations/eopair.svg\" width={200} height={200} alt=\"Image of a cube with an EOPair case\" lnk=\"https://visualcube.api.cubing.net/visualcube.php?fmt=svg&amp;r=y35x-25&amp;bg=t&amp;fc=dldlyrddrggddrldddddwbbdbbd\" />{\"\\n\"}<_components.h1>{\"EOPair: Inserting the Pair and Solving EO at the Same Time\"}</_components.h1>{\"\\n\"}<_components.p>{\"EOPair is an algirithm set for inserting the back-right pair while orienting the edges at the same time. It is divided into four subsets, two with the pair in the U-layer, two with the pair in the R-layer. For both of these positions, there are algorithms for an oriented and a misoriented pair. EOPair used to be part of standard APB. At some point, solvers realized that it only saved about 0.3 moves on average while it consists of 128 algorithms. This trade-off is not worth it in most cases. It is rather recommended to learn the most efficient solutions for all the possible pair cases. If you still want to learn EOPair, it is recommended you start with the misoriented U subset.\"}</_components.p>{\"\\n\"}<_components.p>{\"The algorithms can be found in the \"}<_components.a href=\"https://docs.google.com/spreadsheets/d/1Hs9ikHz-4cfbqBfqvuvE8X9sjCb4Jtm482ZvsFQA2rY/edit?gid=1684874333\">{\"regular EO algorithm sheet\"}</_components.a>{\".\"}</_components.p></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"AAAA,uBAAuB,GACvB,wBAAwB;;;;;;;;;;;AACxB;AAMA;;;AALO,MAAM,WAAW;IACtB,SAAS;IACT,YAAY;IACZ,aAAa;AACf;;AAEO,MAAM,aAAa;AAC1B,SAAS,OAAO,KAAK;IACnB,OAAO,EAAE;AACX;AACO,MAAM,MAAM,OAAO,CAAC;AAC3B,SAAS,kBAAkB,KAAK;IAC9B,MAAM,cAAc;QAClB,GAAG;QACH,IAAI;QACJ,GAAG;QACH,GAAG,IAAA,qIAAkB,GAAE;QACvB,GAAG,MAAM,UAAU;IACrB;IACA,qBAAO;;0BAAE,8OAAC,wIAAK;gBAAC,KAAI;gBAAgC,OAAO;gBAAK,QAAQ;gBAAK,KAAI;gBAAsC,KAAI;;;;;;YAAwH;0BAAK,8OAAC,YAAY,EAAE;0BAAE;;;;;;YAA+E;0BAAK,8OAAC,YAAY,CAAC;0BAAE;;;;;;YAAksB;0BAAK,8OAAC,YAAY,CAAC;;oBAAE;kCAAsC,8OAAC,YAAY,CAAC;wBAAC,MAAK;kCAA2G;;;;;;oBAA8C;;;;;;;;;AACzxC;uCACe","debugId":null}},
    {"offset": {"line": 4025, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/index.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"Welcome to the APB Method Website\",\n  \"filePath\": \"content/index.mdx\",\n  \"timestamp\": 1758384360735\n};\nimport {Steps} from 'nextra/components';\nimport Image from 'next/image';\nexport const sourceCode = \"import { Steps } from 'nextra/components'\\nimport Image from 'next/image'\\n\\n<Image src=\\\"/images/apb_icon.svg\\\" width={250} height={250} alt=\\\"APB Icon\\\"/>\\n# Welcome to the APB Method Website\\nWelcome to **apbmethod.net**! This site is a learning resource for all levels of APB solvers. If you are looking for a tutorial on the method, see [here](/tutorial).\\n\\n## The APB Method\\nAPB is a **3x3 speedsolving method** proposed by **James Straughan aka. Athefre** in 2021. You can check out his overview [here](https://sites.google.com/view/apb-system/overview). Having a movecount of about 48-50 moves and being very algorithm-based, it has **a lot of potential** for being fast at a high level.\\n\\nStandard APB consists of 5 steps:\\n<Steps>\\n    {<h3>2x2x3 block on the left side</h3>}\\n    Solve a 2x2x3 block in the bottom-left. This is usually accomplished by building a Roux-style 1x2x3 block and then extending it by solving the DF and DB edges.\\n\\n    {<h3>Solving the back-right F2L-pair</h3>}\\n    The back-right F2L pair is solved intuitively.\\n\\n    {<h3>Solve the edge-orientation of the remaining edges (EO)</h3>}\\n    The edge-orientation of the remaining edges is solved algorithmically (11 algorithms).\\n\\n    {<h3>Solve the last three F2L pieces (LXS)</h3>}\\n    The remaining three F2L pieces are solved algorithmically (116 algorithms).\\n\\n    {<h3>Solve the last layer</h3>}\\n    The last layer is solved using either OCLL + PLL or ZBLL, which consists of 493 algorithms.\\n</Steps>\\n\\n## About Me\\nHi, this is [JustEnoughAlgorithms](https://www.youtube.com/@justenoughalgorithms) and I'm the creator of this website. I've been using APB since autumn of 2023 and have been using it in competition ever since. I've managed to beat all of my old PBs that I had set with Roux. [My WCA Profile](https://www.worldcubeassociation.org/persons/2022PERR01)\\n\\n## About this site\\nThis website was very much inspired by [zzmethod.com](https://zzmethod.com) made by [crystalcuber](https://www.youtube.com/@crystalcuber). It was created using [nextra](https://nextra.site).\\n\\n## Contribute\\nIf you have an idea or want to contribute, create an issue on this book's [GitHub Page](https://github.com/phalentin/apbmethod.net) or create a pull request.\";\nfunction useTOC(props) {\n  return [{\n    value: \"The APB Method\",\n    id: \"the-apb-method\",\n    depth: 2\n  }, {\n    value: \"About Me\",\n    id: \"about-me\",\n    depth: 2\n  }, {\n    value: \"About this site\",\n    id: \"about-this-site\",\n    depth: 2\n  }, {\n    value: \"Contribute\",\n    id: \"contribute\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h1: \"h1\",\n    h2: \"h2\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><Image src=\"/images/apb_icon.svg\" width={250} height={250} alt=\"APB Icon\" />{\"\\n\"}<_components.h1>{\"Welcome to the APB Method Website\"}</_components.h1>{\"\\n\"}<_components.p>{\"Welcome to \"}<_components.strong>{\"apbmethod.net\"}</_components.strong>{\"! This site is a learning resource for all levels of APB solvers. If you are looking for a tutorial on the method, see \"}<_components.a href=\"/tutorial\">{\"here\"}</_components.a>{\".\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<_components.p>{\"APB is a \"}<_components.strong>{\"3x3 speedsolving method\"}</_components.strong>{\" proposed by \"}<_components.strong>{\"James Straughan aka. Athefre\"}</_components.strong>{\" in 2021. You can check out his overview \"}<_components.a href=\"https://sites.google.com/view/apb-system/overview\">{\"here\"}</_components.a>{\". Having a movecount of about 48-50 moves and being very algorithm-based, it has \"}<_components.strong>{\"a lot of potential\"}</_components.strong>{\" for being fast at a high level.\"}</_components.p>{\"\\n\"}<_components.p>{\"Standard APB consists of 5 steps:\"}</_components.p>{\"\\n\"}<Steps>{<h3>2x2x3 block on the left side</h3>}<_components.p>{\"Solve a 2x2x3 block in the bottom-left. This is usually accomplished by building a Roux-style 1x2x3 block and then extending it by solving the DF and DB edges.\"}</_components.p>{<h3>Solving the back-right F2L-pair</h3>}<_components.p>{\"The back-right F2L pair is solved intuitively.\"}</_components.p>{<h3>Solve the edge-orientation of the remaining edges (EO)</h3>}<_components.p>{\"The edge-orientation of the remaining edges is solved algorithmically (11 algorithms).\"}</_components.p>{<h3>Solve the last three F2L pieces (LXS)</h3>}<_components.p>{\"The remaining three F2L pieces are solved algorithmically (116 algorithms).\"}</_components.p>{<h3>Solve the last layer</h3>}<_components.p>{\"The last layer is solved using either OCLL + PLL or ZBLL, which consists of 493 algorithms.\"}</_components.p></Steps>{\"\\n\"}<_components.h2 id={toc[1].id}>{toc[1].value}</_components.h2>{\"\\n\"}<_components.p>{\"Hi, this is \"}<_components.a href=\"https://www.youtube.com/@justenoughalgorithms\">{\"JustEnoughAlgorithms\"}</_components.a>{\" and I’m the creator of this website. I’ve been using APB since autumn of 2023 and have been using it in competition ever since. I’ve managed to beat all of my old PBs that I had set with Roux. \"}<_components.a href=\"https://www.worldcubeassociation.org/persons/2022PERR01\">{\"My WCA Profile\"}</_components.a></_components.p>{\"\\n\"}<_components.h2 id={toc[2].id}>{toc[2].value}</_components.h2>{\"\\n\"}<_components.p>{\"This website was very much inspired by \"}<_components.a href=\"https://zzmethod.com\">{\"zzmethod.com\"}</_components.a>{\" made by \"}<_components.a href=\"https://www.youtube.com/@crystalcuber\">{\"crystalcuber\"}</_components.a>{\". It was created using \"}<_components.a href=\"https://nextra.site\">{\"nextra\"}</_components.a>{\".\"}</_components.p>{\"\\n\"}<_components.h2 id={toc[3].id}>{toc[3].value}</_components.h2>{\"\\n\"}<_components.p>{\"If you have an idea or want to contribute, create an issue on this book’s \"}<_components.a href=\"https://github.com/phalentin/apbmethod.net\">{\"GitHub Page\"}</_components.a>{\" or create a pull request.\"}</_components.p></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4388, "column": 0}, "map": {"version":3,"sources":["file:///mnt/datadrive/apbmethod.net/content/other-resources.mdx.tsx"],"sourcesContent":["/*@jsxRuntime automatic*/\n/*@jsxImportSource react*/\nimport {useMDXComponents as _provideComponents} from \"next-mdx-import-source-file\";\nexport const metadata = {\n  \"title\": \"Other Resources\",\n  \"filePath\": \"content/other-resources.mdx\",\n  \"timestamp\": 1758384366099\n};\nexport const sourceCode = \"# Other Resources\\n- [APB Mega Doc](https://docs.google.com/document/d/1GznSart4lglO9Q6Q5tLZazRysr5a6D5WnmQ5ouMIOnc/): All the algorithms and links to trainers for them, source of all these links\\n- [APB Website by Athefre](https://sites.google.com/view/apb-system/): Short explanation of all the steps and original public source\\n- [APB Discord Server](https://discord.gg/k4rX4BgmZW): Place to chat and ask questions\\n- [Speedsolving Wiki Entry](https://www.speedsolving.com/wiki/index.php?title=APB): Wiki entry of the method\\n  \\n## Algorithms\\n  \\n### Pair Solving\\n- [Pair Solving](https://docs.google.com/spreadsheets/d/1U1nwq_-HLeDgajuAOVRaH2Jo7X9zSTEBrnIRSv3hzeg/) by Liam Highducheck\\n- [Pair Solving](https://docs.google.com/spreadsheets/d/1Agu9KUs99H2CHI_cEkkmSmwtTWMX6tjQ/) by Kombofuud\\n  \\n### Edge Orientation\\n- [Edge Orientation](https://docs.google.com/spreadsheets/d/1Hs9ikHz-4cfbqBfqvuvE8X9sjCb4Jtm482ZvsFQA2rY/) by Athefre\\n\\nNote that for Standard APB you only need to learn the algorithms in the *dBR Solved EO* tab.\\n\\n### LXS\\n- [LXS](https://docs.google.com/spreadsheets/d/1P2DB0SyA1BrezYJ_g7RJ7_l32Ilxq7lLtr53zlG_TUU/) by Athefre\\n- [LXS patterns for learning](https://docs.google.com/spreadsheets/d/1ACKQXpMK0b8RWGoN9wMDbnF-W-S4mMdeJH5IcjeEyf8/) by Liam Highducheck\\n  \\n### ZBLL\\n- [SpeedCubeDB ZBLL](https://speedcubedb.com/a/ZBLL): big selection of algorithms, but the top algorithm is often not the best one\\n- [Teri's ZBLL](https://docs.google.com/spreadsheets/d/1BiQZkCZvTDRlW6Y6jTBHXPPjZF9k55x8YJgXXs5nhCs/): really optimised algorithms, but getting the right fingertricks can be tricky. These algorithms require a lot of practice and might be riskier than you'd like.\\n- [Juju ZBLL](https://docs.google.com/spreadsheets/d/1-uwmZHf4vwJxFgeB3-TiF8MQ0RFSS30d5CUK96PoIwk/): good algorithms that are used by a world-class ZBLL user. Sometimes there are better algorithms available.\\n- [ZBLL Explorer](https://pepkin88.me/zbll-explorer/): big selection of algorithms, better ranking than SpeedCubeDB's, shows the relation between cases\\n  \\n## Trainers\\n- [EOPair Trainer](https://gregorycannon.github.io/EOTrainer/) by Greg Cannon\\n- [LXS Trainer](https://apurplefrog.github.io/lxstrainer/) by apurplefrog\\n- [ZBLL Trainer](https://bestsiteever.ru/zbll/) by Roman Strakhov\";\nfunction useTOC(props) {\n  return [{\n    value: \"Algorithms\",\n    id: \"algorithms\",\n    depth: 2\n  }, {\n    value: \"Pair Solving\",\n    id: \"pair-solving\",\n    depth: 3\n  }, {\n    value: \"Edge Orientation\",\n    id: \"edge-orientation\",\n    depth: 3\n  }, {\n    value: \"LXS\",\n    id: \"lxs\",\n    depth: 3\n  }, {\n    value: \"ZBLL\",\n    id: \"zbll\",\n    depth: 3\n  }, {\n    value: \"Trainers\",\n    id: \"trainers\",\n    depth: 2\n  }];\n}\nexport const toc = useTOC({});\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return <><_components.h1>{\"Other Resources\"}</_components.h1>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/document/d/1GznSart4lglO9Q6Q5tLZazRysr5a6D5WnmQ5ouMIOnc/\">{\"APB Mega Doc\"}</_components.a>{\": All the algorithms and links to trainers for them, source of all these links\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://sites.google.com/view/apb-system/\">{\"APB Website by Athefre\"}</_components.a>{\": Short explanation of all the steps and original public source\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://discord.gg/k4rX4BgmZW\">{\"APB Discord Server\"}</_components.a>{\": Place to chat and ask questions\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://www.speedsolving.com/wiki/index.php?title=APB\">{\"Speedsolving Wiki Entry\"}</_components.a>{\": Wiki entry of the method\"}</_components.li>{\"\\n\"}</_components.ul>{\"\\n\"}<_components.h2 id={toc[0].id}>{toc[0].value}</_components.h2>{\"\\n\"}<_components.h3 id={toc[1].id}>{toc[1].value}</_components.h3>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1U1nwq_-HLeDgajuAOVRaH2Jo7X9zSTEBrnIRSv3hzeg/\">{\"Pair Solving\"}</_components.a>{\" by Liam Highducheck\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1Agu9KUs99H2CHI_cEkkmSmwtTWMX6tjQ/\">{\"Pair Solving\"}</_components.a>{\" by Kombofuud\"}</_components.li>{\"\\n\"}</_components.ul>{\"\\n\"}<_components.h3 id={toc[2].id}>{toc[2].value}</_components.h3>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1Hs9ikHz-4cfbqBfqvuvE8X9sjCb4Jtm482ZvsFQA2rY/\">{\"Edge Orientation\"}</_components.a>{\" by Athefre\"}</_components.li>{\"\\n\"}</_components.ul>{\"\\n\"}<_components.p>{\"Note that for Standard APB you only need to learn the algorithms in the \"}<_components.em>{\"dBR Solved EO\"}</_components.em>{\" tab.\"}</_components.p>{\"\\n\"}<_components.h3 id={toc[3].id}>{toc[3].value}</_components.h3>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1P2DB0SyA1BrezYJ_g7RJ7_l32Ilxq7lLtr53zlG_TUU/\">{\"LXS\"}</_components.a>{\" by Athefre\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1ACKQXpMK0b8RWGoN9wMDbnF-W-S4mMdeJH5IcjeEyf8/\">{\"LXS patterns for learning\"}</_components.a>{\" by Liam Highducheck\"}</_components.li>{\"\\n\"}</_components.ul>{\"\\n\"}<_components.h3 id={toc[4].id}>{toc[4].value}</_components.h3>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.a href=\"https://speedcubedb.com/a/ZBLL\">{\"SpeedCubeDB ZBLL\"}</_components.a>{\": big selection of algorithms, but the top algorithm is often not the best one\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1BiQZkCZvTDRlW6Y6jTBHXPPjZF9k55x8YJgXXs5nhCs/\">{\"Teri’s ZBLL\"}</_components.a>{\": really optimised algorithms, but getting the right fingertricks can be tricky. These algorithms require a lot of practice and might be riskier than you’d like.\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://docs.google.com/spreadsheets/d/1-uwmZHf4vwJxFgeB3-TiF8MQ0RFSS30d5CUK96PoIwk/\">{\"Juju ZBLL\"}</_components.a>{\": good algorithms that are used by a world-class ZBLL user. Sometimes there are better algorithms available.\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://pepkin88.me/zbll-explorer/\">{\"ZBLL Explorer\"}</_components.a>{\": big selection of algorithms, better ranking than SpeedCubeDB’s, shows the relation between cases\"}</_components.li>{\"\\n\"}</_components.ul>{\"\\n\"}<_components.h2 id={toc[5].id}>{toc[5].value}</_components.h2>{\"\\n\"}<_components.ul>{\"\\n\"}<_components.li><_components.a href=\"https://gregorycannon.github.io/EOTrainer/\">{\"EOPair Trainer\"}</_components.a>{\" by Greg Cannon\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://apurplefrog.github.io/lxstrainer/\">{\"LXS Trainer\"}</_components.a>{\" by apurplefrog\"}</_components.li>{\"\\n\"}<_components.li><_components.a href=\"https://bestsiteever.ru/zbll/\">{\"ZBLL Trainer\"}</_components.a>{\" by Roman Strakhov\"}</_components.li>{\"\\n\"}</_components.ul></>;\n}\nexport default _createMdxContent;\n"],"names":[],"mappings":"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","debugId":null}}]
}